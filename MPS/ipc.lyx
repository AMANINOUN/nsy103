#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard

Un processus est un programme en cours d'exécution.
 Sous Unix, chaque processus possède un identifiant unique, le processus
 ID(PID) dit "pid" à la française, "pi aie di" pour les gens 'aware'.
 Vous pouvez obtenir la liste des processus tournants et leur pid correspondant
 à un instant t grâce à la commande 'ps ax'.
 On aperçoit que la génération du pid d'un processus est simple : elle est
 incrémentielle.
 Le premier programme lancé une fois le noyau chargé (le programme 'init'
 normalement) aura le chiffre 1 pour pid, le second 2 etc ...
 Les processus appartiennent généralement a l'utilisateur qui les a lancés
 et héritent donc de ses droits sauf si le fichier exécutable possède l'attribut
 SUID(SaveUID); dans ce cas, le processus récupère les droits du propriétaire
 du fichier.
 Nous allons voir dans ce cours comment, à partir d'un seul programme, on
 peut créer une application dite 'multitache'.
 
\layout Section

Manipulation de processus 
\layout Standard

Il existe plusieurs fonctions qui permettent de lancer des commandes à partir
 d'un programme C : 
\layout Paragraph

- int system(char *string)  
\layout Standard

La chaine prise en argument est le nom d'un programme, d'un script shell
 exécutable ou d'une commande que l'on souhaite lancer.
 
\layout Standard

La valeur de retour est le statu de sortie du shell ayant lancé cette commande.
 D'une manière générale, un chiffre différent de 0 signifie qu'une erreur
 s'est produite.
 
\layout Standard

system() est composé de trois appels systèmes que nous allons décrire :
 execl(), wait() et fork() 
\layout Standard

l'exemple suivant montre l'utilisation des primitives système 
\emph on 
mkdir
\emph default 
 et 
\emph on 
rmdir
\emph default 
 avec l'utilisation de la primitive 
\emph on 
system
\layout Standard


\begin_inset Include \verbatiminput{prog_linux/20/exemple_mkdir.c}

\end_inset 


\layout Paragraph

- execl(char *path, char *arg0, ..., char *argn, 0)  
\layout Standard

execl() veut dire "EXECute and Leave".
 Cette fonction va donc créer un nouveau processus qui va remplacer le processus
 courant en mémoire.
 
\layout Standard

Le dernier paramètre doit toujours être 0.
 
\layout Standard

path est le chemin complet du fichier exécutable qu'on souhaite lancer.
 
\layout Standard

arg0 est le nom de la commande (donc le nom du fichier) et arg1 à argn sont
 les arguments pour la commande.
 
\layout Description

- int fork() 
\layout Standard

C'est une fonction très utile qui permet, à partir d'un processus (père),
 de créer un deuxième processus identique (fils).
 
\layout Standard

En cas de succès, fork() va renvoyer 0 au processus fils et le pid du processus
 fils au père.
 
\layout Standard

En cas d'erreur, aucun fils n'est créé et fork() renvoie -1.
 
\layout Standard

Cette fonction va donc permettre de créer des programmes multitaches simples.
 
\layout Standard

Voyer l'effet de cet exemple:
\layout Standard


\begin_inset Include \verbatiminput{Processus/exo1.c}

\end_inset 


\layout LyX-Code

Resultat de l'execution:
\layout LyX-Code

[pfares@ghadir Processus]$ ./a.out  Valeur retournee par la fonction fork:
 6880 Je suis le processus numero 6879  Valeur retournee par la fonction
 fork: 0 Je suis le processus numero 6880 
\layout Standard

Un peut d'expication
\layout Standard

Exemple : 
\layout Standard


\begin_inset Include \verbatiminput{Processus/ex1.c}

\end_inset 


\layout Standard

Lorsqu'on exécute plusieurs fois ce programme, on s'aperçeoit que l'ordre
 d'affichage des deux phrases peut changer.
 Ceci est du au fait que les deux processus fonctionnent en même temps sur
 le système.
 C'est le système (le noyau) qui ordonnance les différents processus et
 leur attribue du temps CPU.
 Cet ordonnancement dépend de nombreux paramètres (notamment de l'utilisation
 par d'autres processus du CPU) qui font qu'il est difficile de prévoir
 quel processus obtiendra du temps CPU avant l'autre.
 Un autre problème est l'absence de données communes aux deux processus
 car l'ensemble des variables est recopié en mémoire; lorsqu'un processus
 modifie une variable, cette même variable reste intacte dans l'autre processus
 (seul le nom des variables reste le même, physiquement, elles existent
 à deux emplacements mémoire différents).
 Nous verrons plus tard quels sont les moyens qui permettent de contourner
 ces problèmes.
 
\layout Description

- int wait(int *status_location) 
\layout Standard

Cette fonction force un processus parent à attendre la fin d'un processus
 enfant ou l'envoi d'un signal à intercepter.
 
\layout Standard

La valeur de retour est le pid du fils et la variable status_location est
 remplie avec le status de sortie de celui-ci.
 
\layout Standard

- unsigned int sleep(unsigned int nb_sec)  
\layout Standard

Permet d'endormir un processus pour une durée de nb_sec secondes.
 
\layout Standard

La valeur renvoyée est 0 si le temps s'est écoulé ou le nombre de secondes
 restantes si un signal a réveillé le processus.
 
\layout Description

- exit(int status) 
\layout Standard

Termine le processus appelant cette fonction qui retourne aussi son status
 de sortie.
 Cette valeur peut êrécupéréetre récupérée par d'autres processus ou bien
 par le shell dans la variable "$?".
 
\layout Standard

Les fichiers entêtes permettant d'accéder à ces fonctions sont unistd.h et
 stdlib.h (sys/types.h et sys/wait.h pour la fonction wait() ) .
 
\layout Standard

Nous avons donc vu comment on crée plusieurs processus à partir d'un programme.
 Maintenant, nous allons étudier différentes façons de les faire communiquer
 entre eux.
 Ces moyens de communication permettront d'échanger des informations entre
 les processus mais surtout, il permettront de les contrôleur plus finement.
 Nous avons à disposition plusieurs méthodes pour accomplir ceci: 
\layout Itemize

les pipes 
\layout Itemize

les signaux 
\layout Itemize

les files de messages 
\layout Itemize

les sémaphores  la mémoire partagée
\layout Itemize

les sockets (non présentés dans ce cours) 
\layout Section


\begin_inset LatexCommand \label{sec:pipe}

\end_inset 

Les pipes (tubes)
\layout Standard

Le pipe est un mécanisme qui prend la sortie d'un processus comme entrée
 d'un autre et inversement.
 
\layout Standard

Il existe deux façon d'ouvrir un pipe.
 L'une est une ouverture formatée, l'autre une ouverture bas niveau.
 
\layout Standard

- ouverture formatée : 
\layout Paragraph

FILE *popen(char *command, char *type)  
\layout Standard

ouvre un pipe dans lequel 'command' sera un programme connecté au processus
 appelant.
 
\layout Standard

Le type est soit r pour la lecture, soit w pour l'écriture.
 
\layout Standard

La valeur de retour est un pointeur sur un flux ou NULL en cas d'echec.
 
\layout Standard

On utilise ensuite fprintf() et fscanf() pour communiquer avec le programme
 à travers ce tuyau.
 
\layout Standard

exercice 1: Ecrire un programme utilisant popen() et le programme mail pour
 envoyer un email à votre compte sur votre poste.
 
\layout Standard

- ouverture bas niveau : 
\layout Paragraph

int pipe(int fd[2]) 
\layout Standard

Cette fonction crée un pipe et renvoie deux descripteurs de fichiers.
 fd[0] est ouvert en mode lecture et fd[1] est ouvert en mode écriture.
 
\layout Standard

La valeur de retour est 0 en cas de réussite, -1 en cas d'echec et la variable
 errno est mise à jour.
 
\layout Standard

Un pipe de ce type va permettre à deux processus crées avec un fork() de
 communiquer en utilisant read() et write().
 
\layout Standard

Les pipes sont bien pratiques mais une fois de plus, les deux processus
 ne sont pas forcement parfaitement synchronisés ce qui implique l'utilisation
 de wait() afin que le père attende son fils; sans cela, on risque l'embrouille
 familial ...
 En effet, si le père est en avance sur le fils, il va lire son propre message
 dans le pipe car il aura appelé read() avant son fils.
 
\layout Standard

exercice 2: Ecrire un programme qui crée deux processus avec fork() et dont
 chaque processus affiche une phrase envoyée par l'autre.
 
\layout Section

Les files de messages 
\layout Standard

C'est un autre mécanisme qui permet l'échange de messages entre processus.
 Le fonctionnement est différent de celui des pipes car nous n'avons plus
 affaire à un flux mais à des messages de taille fixe.
 Les files sont en outre plus souples que les pipes, notamment pour la transmiss
ion sélective des messages (c.a.d.
 pour choisir quel processus doit recevoir un message).
 
\layout Standard

Un message est composé d'un tableau de caractères et d'un entier long.
 
\layout Standard

L'entier long est le type du message.
 Il servira à déterminer de quel type d'information le corps du message
 se compose; il servira aussi à déterminer si un processus doit ou non le
 récupérer.
 
\layout Standard

Le tableau de caractère représente le corps du message.
 
\layout Standard

Les files de messages peuvent être de deux types : bloquantes ou non bloquantes.
 
\layout Standard

Une file de messages est définie par une structure msqid_ds qui est allouée
 et initialisée lors de sa création.
 
\layout Standard

Certains champs peuvent êtres modifiés en appelant msgctl.( Voir info ipc
 pour la définition de la structure).
 
\layout Standard

La fonction permettant de créer une file de messages est msgget() : 
\layout Standard

- int msgget(key_t key, int msgflg)  
\layout Standard

la valeur de retour est un identifiant (msqid) créé à partir de key; c'est
 cet identifiant qui va permettre à différents processus de partager une
 même file.
 
\layout Standard

msgflg est un entier représentant les différentes options (combinées grâce
 à un ou logique |).
 
\layout Standard

man msgget pour le detail des options.
 
\layout Standard

La fonction permettant de modifier les attribut d'une file est msgctl():
 
\layout Standard

- int msgctl(int msqid, int cmd, struct msqid_ds *buf) 
\layout Standard

Cette fonction permet, entre autres, de modifier les permissions d'une file.
 
\layout Standard

msqid 
\layout Standard

est l'identifiant d'une file existante.
 
\layout Standard

cmd 
\layout Standard

est l'un de ces flags: 
\layout Standard

IPC_STAT 
\layout Standard

- Remplis la structure pointée par buf avec les informations de status de
 la file.
 Le processus doit avoir le droit de lecture sur la file.
 
\layout Standard

IPC_SET 
\layout Standard

- Règle le GID et l' UID du propriétaire, les permissions et la taille de
 la file.
 Le processus doit avoir l'EUID du propriétaire ou du root.
 
\layout Standard

IPC_RMID 
\layout Standard

- supprime la file.
 Encore une fois, un man msgctl vous donnera les détails de la fonction,
 notamment ses valeurs de retour.
 
\layout Standard

Pour envoyer et recevoir des messages, il faut créer créer la structure
 contenant l'entier long et un tableau de caractères de taille fixe comme
 ceci : 
\layout Standard

struct msgbuf { long int mtype; char mtext[TAILLE_MAX_DES_MESSAGES]; };
 
\layout Standard

Ensuite on utilise les fonctions msgsnd() et msgrcv().
 
\layout Standard

- int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 
\layout Standard

- int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
 
\layout Standard

Ces fonctions servent respectivement à envoyer et recevoir des messages
 dans la file.
 
\layout Standard

msqid 
\layout Standard

est l'identifiant d'une fie existante.
 
\layout Standard

msgp 
\layout Standard

est un pointeur vers une structure contenant le type de message et son contenu.
 
\layout Standard

msgz 
\layout Standard

est la longueur en octets du message.
 
\layout Standard

msgtyp 
\layout Standard

est le type de message reçu, spécifié dans le champ mtype du processus émetteur.
 
\layout Standard

msgflg 
\layout Standard

spécifie l'action à entreprendre dans l'un de ces deux cas: 
\layout Standard

- 
\layout Standard

Le nombre d'octets dans la file est déjà égal à msg_qbytes.
 
\layout Standard

- 
\layout Standard

Le nombre total de messages sur toutes les files du système est égal aux
 limites de celui-ci.
 
\layout Standard

L'action à prendre est spécifié avec le flag NOWAIT qu'on applique à msgflg
 avec un ou binaire : 
\layout Standard

- Si le flag est appliqué, le message ne sera pas envoyé et la fonction
 reviendra immédiatement avec le code d'erreur EAGAIN.
 
\layout Standard

- Si le flag n'est pas appliqué, le processus ayant appelé cette fonction
 sera bloqué jusqu'à ce que l'un de ces cas arrive : 
\layout Standard

- La cause du blocage n'existe plus, et dans ce cas le message est envoyé.
 
\layout Standard

- La file à été supprimée, dans ce cas la fonction revoie -1.
 
\layout Standard

- Le processus ayant appelé la fonction reçoit un signal à gérer, dans ce
 cas le message n'est pas envoyé et la fonction se termine en revoyant le
 code d'erreur EINTR.
 
\layout Standard

Exercice 5: Créez deux programmes.
 Le premier doit déterminer la valeur du plus grand entier inférieur à 10000
 et envoyer son résultat au second par l'intermédiaire d'une file.
 Le second doit lancer le premier et afficher le temps qui passe, seconde
 par seconde en attendant que le résultat arrive.
 
\layout Section

Sémaphores selon System V 
\layout Standard

D'une manière générale, les sémaphores permettent d'obtenir un accès en
 exclusion mutuelle à une ressource.
 Ça c'est la description typique et pas forcement très claire.
 En fait ça veut simplement dire qu'on va pouvoir, grâce aux sémaphores,
 empêcher plusieurs processus d'accéder en même temps à une ressource (une
 zone de mémoire partagée par exemple).
 Les sémaphores system V sont très gourmands en ressources et sont bien
 moins efficaces que les sémaphores de la norme POSIX.
 Nous n'allons donc pas nous attarder trop longtemps mais il est néanmoins
 intéressant d'y jeter un oeil car il y a encore peu longtemps (pour les
 dynausores), Linux n'implementait pas la norme POSIX (pour la programmation
 multitâche).
 De nombreux programmes utilisent donc encore ces mécanismes.
 Voici donc une brève description des fonctions utiles: 
\layout Standard

int semget(key_t key, int nsems, int semflg); 
\layout Standard

La valeur de retour de cette fonction est un identifiant de jeu de sémaphores
 (semid).
 
\layout Standard

key 
\layout Standard

est un identifiant accès.
 C'est le même principe que la clef des files de messages.
 
\layout Standard

nsems 
\layout Standard

spécifie le nombre d'éléments dont sera composé le tableau de sémaphores.
 
\layout Standard

semflg 
\layout Standard

représente les option de création et l'accès au jeu de sémaphores.
 
\layout Standard

int semctl(int semid, int semnum, int cmd, union semun arg); 
\layout Standard

Permet de controler les caractéristiques d'un jeu de sémaphores.
 
\layout Standard

int semop(int semid, struct sembuf *sops, unsigned nsops); 
\layout Standard

semid 
\layout Standard

est l'identifiant de je de sémaphores retourné par semget() .
 
\layout Standard

sops 
\layout Standard

est un pointeur sur un tableau de structures.
 Chaque structure contient un numéro de sémaphore, l'action à effectuer,
 des flags de contrôle.
 
\layout Standard

l'action 
\layout Standard

à effectuer est soit : 
\layout Standard

- 
\layout Standard

incrémenter le sémaphore d'une valeur si on spécifie une valeur positive.
 
\layout Standard

- 
\layout Standard

décrémenter le sémaphore d'une valeur si on spécifie une valeur négative.
 Si on essaye de décrémenter le sémaphore en dessous de zéro, la fonction
 échoue ou se bloque selon qu'on a spécifié ou non le flag IPC_NOWAIT dans
 les options de contrôle .
 
\layout Standard

- 
\layout Standard

attendre que le sémaphore atteigne la valeur 0 si on a spécifié 0.
 
\layout Standard

Voici un bon exemple de d'utilisation de sémaphores pêché dans une documentation
 sur System V: 
\layout Standard

#include <stdio.h>
\layout Standard

#include <sys/types.h>
\layout Standard

#include <sys/ipc.h>
\layout Standard

#include <sys/sem.h> 
\layout Standard

union semun {
\layout Standard

int val;
\layout Standard

struct semid_ds *buf;
\layout Standard

ushort *array;
\layout Standard

}; 
\layout Standard

main()
\layout Standard

{ 
\layout Standard

int i,j;
\layout Standard

int pid;
\layout Standard

int semid; /* semid of semaphore set */
\layout Standard

key_t key = 1234; /* key to pass to semget() */
\layout Standard

int semflg = IPC_CREAT | 0666; /* semflg to pass to semget() */
\layout Standard

int nsems = 1; /* nsems to pass to semget() */
\layout Standard

int nsops; /* number of operations to do */
\layout Standard

struct sembuf *sops = (struct sembuf *) malloc(2*sizeof(struct sembuf));
 /* ptr to operations to perform */
\layout Standard

/* set up semaphore */
\layout Standard

(void) fprintf(stderr, "
\backslash 
nsemget: Setting up seamaphore: semget(%#lx, %
\backslash 

\layout Standard

%#o)
\backslash 
n",key, nsems, semflg);
\layout Standard

if ((semid = semget(key, nsems, semflg)) == -1) {
\layout Standard

perror("semget: semget failed");
\layout Standard

exit(1);
\layout Standard

} else
\layout Standard

(void) fprintf(stderr, "semget: semget succeeded: semid =
\backslash 

\layout Standard

%d
\backslash 
n", semid); /* get child process */
\layout Standard

if ((pid = fork()) < 0) {
\layout Standard

perror("fork");
\layout Standard

exit(1);
\layout Standard

}
\layout Standard

if (pid == 0)
\layout Standard

{ /* child */
\layout Standard

i = 0;
\layout Standard

while (i < 3) {/* allow for 3 semaphore sets */
\layout Standard

nsops = 2;
\layout Standard

/* wait for semaphore to reach zero */
\layout Standard

sops[0].sem_num = 0; /* We only use one
\layout Standard

track */
\layout Standard

sops[0].sem_op = 0; /* wait for semaphore flag to become zero */
\layout Standard

sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous */
\layout Standard

sops[1].sem_num = 0;
\layout Standard

sops[1].sem_op = 1; /* increment semaphore -- take control of track */
\layout Standard

sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
\layout Standard

/* Recap the call to be made.
 */
\layout Standard

(void) fprintf(stderr,"
\backslash 
nsemop:Child Calling
\layout Standard

semop(%d, &sops, %d) with:", semid, nsops);
\layout Standard

for (j = 0; j < nsops; j++)
\layout Standard

{
\layout Standard

(void) fprintf(stderr, "
\backslash 
n
\backslash 
tsops[%d].sem_num = %d, ", j,
\layout Standard

sops[j].sem_num);
\layout Standard

(void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
\layout Standard

(void) fprintf(stderr, "sem_flg = %#o
\backslash 
n", sops[j].sem_flg);
\layout Standard

}
\layout Standard

/* Make the semop() call and report the results.
 */
\layout Standard

if ((j = semop(semid, sops, nsops)) == -1) {
\layout Standard

perror("semop: semop failed");
\layout Standard

}
\layout Standard

else
\layout Standard

{
\layout Standard

(void) fprintf(stderr, "
\backslash 
tsemop: semop returned
\layout Standard

%d
\backslash 
n", j);
\layout Standard

(void) fprintf(stderr, "
\backslash 
n
\backslash 
nChild Process Taking Control of Track: %d/3
\layout Standard

times
\backslash 
n", i+1);
\layout Standard

sleep(5); /* DO Nothing for 5 seconds */ 
\layout Standard

nsops = 1;
\layout Standard

/* wait for semaphore to reach zero */
\layout Standard

sops[0].sem_num = 0;
\layout Standard

sops[0].sem_op = -1; /* Give UP COntrol of
\layout Standard

track */
\layout Standard

sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore,
\layout Standard

asynchronous */
\layout Standard

if ((j = semop(semid, sops, nsops)) == -1) {
\layout Standard

perror("semop: semop failed");
\layout Standard

}
\layout Standard

else
\layout Standard

(void) fprintf(stderr, "Child Process
\layout Standard

Giving up Control of Track: %d/3 times
\backslash 
n", i+1);
\layout Standard

sleep(5); /* halt process to allow parent to catch semaphor
\layout Standard

change first */
\layout Standard

}
\layout Standard

++i;
\layout Standard

}
\layout Standard

}
\layout Standard

else /* parent */
\layout Standard

{ /* pid hold id of child */
\layout Standard

i = 0;
\layout Standard

while (i < 3) { /* allow for 3 semaphore sets */
\layout Standard

nsops = 2;
\layout Standard

/* wait for semaphore to reach zero */
\layout Standard

sops[0].sem_num = 0;
\layout Standard

sops[0].sem_op = 0; /* wait for
\layout Standard

semaphore flag to become zero */
\layout Standard

sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous */
\layout Standard

sops[1].sem_num = 0;
\layout Standard

sops[1].sem_op = 1; /* increment semaphore --
\layout Standard

take control of track */
\layout Standard

sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
\layout Standard

/* Recap the call to be made.
 */
\layout Standard

(void) fprintf(stderr,"
\backslash 
nsemop:Parent Calling
\layout Standard

semop(%d, &sops, %d) with:", semid, nsops);
\layout Standard

for (j = 0; j < nsops; j++)
\layout Standard

{
\layout Standard

(void) fprintf(stderr, "
\backslash 
n
\backslash 
tsops[%d].sem_num = %d, ", j,
\layout Standard

sops[j].sem_num);
\layout Standard

(void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
\layout Standard

(void) fprintf(stderr, "sem_flg = %#o
\backslash 
n", sops[j].sem_flg);
\layout Standard

}
\layout Standard

/* Make the semop() call and report the results.
 */
\layout Standard

if ((j = semop(semid, sops, nsops)) == -1) {
\layout Standard

perror("semop: semop failed");
\layout Standard

}
\layout Standard

else
\layout Standard

{
\layout Standard

(void) fprintf(stderr, "semop: semop returned %d
\backslash 
n", j);
\layout Standard

(void) fprintf(stderr, "Parent Process Taking
\layout Standard

Control of Track: %d/3 times
\backslash 
n", i+1);
\layout Standard

sleep(5); /* Do nothing for 5 seconds */
\layout Standard

nsops = 1;
\layout Standard

/* wait for semaphore to reach zero */
\layout Standard

sops[0].sem_num = 0;
\layout Standard

sops[0].sem_op = -1; /* Give UP COntrol of
\layout Standard

track */
\layout Standard

sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore,
\layout Standard

asynchronous */
\layout Standard

if ((j = semop(semid, sops, nsops)) == -1) {
\layout Standard

perror("semop: semop failed");
\layout Standard

}
\layout Standard

else
\layout Standard

(void) fprintf(stderr, "Parent Process Giving up Control
\layout Standard

of Track: %d/3 times
\backslash 
n", i+1);
\layout Standard

sleep(5); /* halt process to allow child to catch semaphor change
\layout Standard

first */
\layout Standard

}
\layout Standard

++i;
\layout Standard

}
\layout Standard

}
\layout Standard

}
\layout Section

Mémoire partagée selon System V 
\layout Standard

On à vu qu'avec l'appel fork(), les variables n'étaient pas partagées entre
 les processus mais que chacun travaillait sur sa propre copie de celles-ci.
 Le seul moyen pour partager des données jusqu'ici était d'utiliser des
 pipes ou des files pour échanger des valeurs de variables.
 Tout ceci n'est bien évidement pas la solution la plus optimale car il
 y a là redondance des données.
 Heureusement, la norme System V définit des fonctions qui permettent de
 partager un espace mémoire (donc des données) entre plusieurs processus.
 Leur fonctionnement est des plus simple à l'instar des files de messages
 mais encore une fois, la version System V de la mémoire partagée n'est
 pas la plus efficace, l'implementation (POSIX) présente sur Solaris fonctionne
 mieux mais n'est malheureusement pas disponible sur Linux et *BSD.
 
\layout Standard

La gestion de la mémoire partagée nécessite quelques fonctions que nous
 allons définir de suite.
 
\layout Standard

La définition des structures et les prototypes des fonctions que nous allons
 utiliser se trouve dans les fichiers d'en-tête suivants : sys/types.
 hsys/ipc.h sys/shm.h 
\layout Standard

int shmget(key_t key, size_t size, int shmflg); 
\layout Standard

On utilise cette fonction pour obtenir l'accès à un segment de mémoire partagée.
 
\layout Standard

key 
\layout Standard

, tout comme pour les files de messages est un identifiant permettant à
 différents processus d'accéder à la même zone de mémoire partagée.
 
\layout Standard

size 
\layout Standard

est l'espace en octets alloué pour cette zone.
 
\layout Standard

shmflg 
\layout Standard

représente les flags de création et d'accès du segment.
 Le fonctionnement de ces flags est le même que celui des files.
 
\layout Standard

La valeur de retour de cette fonction est un identifiant de segment de mémoire
 partagée.
 Si le a déjà été crée, la fonction renvoie jute l'identifiant.
 
\layout Standard

int shmctl(int shmid, int cmd, struct shmid_ds *buf); 
\layout Standard

Est utilisée pour changer les permissions du segment de mémoire partagée
 et d'autres options en fournissant les flags suivants dans l'argument cmd
 : 
\layout Standard

SHM_LOCK 
\layout Standard

- Bloque le segment de mémoire.
 Le processus doit avoir EUID root pour effectuer cette action.
 
\layout Standard

SHM_UNLOCK 
\layout Standard

- Idem mais débloque le segment.
 
\layout Standard

IPC_STAT 
\layout Standard

- Retourne les informations de status contenues dans la structure de controle
 et les place dans le buffer pointé par buf.
 
\layout Standard

IPC_SET 
\layout Standard

- Change les permissions ainsi de l'EUID et le EGID.
 Le processus doit avoir l'EUID du propriétaire, du créateur ou du root
 pour utiliser cette commande.
 
\layout Standard

IPC_RMID 
\layout Standard

- Supprime le segment de mémoire partagée.
 
\layout Standard

void *shmat(int shmid, const void *shmaddr, int shmflg); 
\layout Standard

Permet d'attacher un segment de mémoire partagée précédemment crée avec
 shmeget() à un pointeur.
 
\layout Standard

shmid 
\layout Standard

est l'identifiant retourné par shmget().
 
\layout Standard

shmaddr 
\layout Standard

est l'adresse d'attachement.
 
\layout Standard

shmflg 
\layout Standard

représente les flags d'options pour l'attachement.
 
\layout Standard

Si shmaddr vaut 0, le système va essayer de prendre lui même une zone mémoire
 libre dans l'intervalle 1-1.5G0.
 
\layout Standard

Si shmaddr n'est pas nul et si SHM_RND est fournit dans shmflg, l'attachement
 l'attachement se fait l'adresse shmaddr arrondie au multiple inférieur
 de SHMLBA.
 Si SHM_RND n'est pas spécifié, shmaddr doit être aligné sur une frontière
 de page mémoire et l'attachement se fait à cet endroit.
 
\layout Standard

Si SHM_RDONLY est spécifié, le segment est attaché en lecture seule.
 Sinon, le segment est attaché en lecture/écriture.
 
\layout Standard

int shmdt( void *shmaddr); 
\layout Standard

Détache le segment de mémoire partagé à l'adresse indiquée par par shmaddr.
 
\layout Standard

Voici un exemple d'utilisation de cette implémentation : 
\layout Standard

Nous allons créer 2 programmes tout simples qui traitent une même chaîne
 (en mémoire partagée biensur).
 Le premier propose à l'utilisateur d'entrer une chaîne de caractères puis
 la place en mémoire partagée.
 Le seconde prend cette chaîne et la 'crypte'.
 
\layout Standard

Premier programme : 
\layout Standard

#include <sys/types.h>
\layout Standard

#include <sys/ipc.h>
\layout Standard

#include <sys/shm.h>
\layout Standard

#include <stdio.h> 
\layout Standard

#define TAILLE_MEMOIRE 64 
\layout Standard

int main(void)
\layout Standard

{
\layout Standard

char c;
\layout Standard

int shmid;
\layout Standard

key_t key;
\layout Standard

char *shm, *s; 
\layout Standard

key = 4242;
\layout Standard

if ((shmid = shmget(key, TAILLE_MEMOIRE, IPC_CREAT | 0666)) < 0) {
\layout Standard

perror("shmget");
\layout Standard

exit(-1);
\layout Standard

} 
\layout Standard

if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
\layout Standard

perror("shmat");
\layout Standard

exit(-1);
\layout Standard

}
\layout Standard

s = shm;
\layout Standard

printf("Entrez une phrase : ");
\layout Standard

fgets(s, TAILLE_MEMOIRE, stdin);
\layout Standard

c = shm[0];
\layout Standard

while (*shm == c)
\layout Standard

sleep(1); 
\layout Standard

printf("
\backslash 
nVoici la chaine cryptée : %s
\backslash 
n",shm);
\layout Standard

if ((shmctl(shmid,IPC_RMID,(struct shmid_ds *) NULL))<0) {
\layout Standard

perror("shmctl");
\layout Standard

exit(-1);
\layout Standard

}
\layout Standard

return 0;
\layout Standard

}
\layout Standard

Second programme : 
\layout Standard

#include <sys/types.h>
\layout Standard

#include <sys/ipc.h>
\layout Standard

#include <sys/shm.h>
\layout Standard

#include <stdio.h> 
\layout Standard

#define TAILLE_MEMOIRE 64 
\layout Standard

int main(void)
\layout Standard

{
\layout Standard

int shmid;
\layout Standard

key_t key;
\layout Standard

char *shm;
\layout Standard

key = 4242;
\layout Standard

if ((shmid = shmget(key, TAILLE_MEMOIRE, 0666)) < 0) {
\layout Standard

perror("shmget");
\layout Standard

exit(-1);
\layout Standard

}
\layout Standard

if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
\layout Standard

perror("shmat");
\layout Standard

exit(-1);
\layout Standard

}
\layout Standard

printf("Chaine trouvée : %s
\backslash 
n",shm);
\layout Standard

while (*shm != '
\backslash 
0') {
\layout Standard

*shm += 1;
\layout Standard

shm++;
\layout Standard

}
\layout Standard

printf("Chaine crypté.
\backslash 
n");
\layout Standard

return 0;
\layout Standard

}
\layout Standard

Dans ce cas (simple), seul un processus modifie la donnée partagée.
 Mais dans d'autres situations, il sera nécessaire d'établir des règles
 pour accéder à celle-ci dans un ordre précis.
 Les sémaphores ou les threads peuvent être bien utiles dans ce cas ...
 
\layout Section

7 Projection en mémoire façon BSD 
\layout Standard

La projection en mémoire est un moyen d'accéder à un fichier ou un périphérique
 de façon très efficace.
 C'est monstrueusement pratique ! Pour un fichier 'mappé' (projetté) en
 mémoire, la lecture et l'écriture des données se fait dans la RAM et non
 sur le disque, ce qui rend ces opérations beaucoup, beaucoup plus rapides
 .
 On peu aussi utiliser ce type de partage sur des périphériques tels qu'une
 carte son, une carte video, même une carte télé ...
 Grâce à cela, on va pouvoir accéder à la mémoire du périphérique lui-même.
 Pour réaliser cela nous avons besoin de ces fonctions : 
\layout Standard

void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset
); 
\layout Standard

Va allouer une zone de mémoire dans laquelle pourra être éventuellement
 projeté un fichier ou un périphérique.
 
\layout Standard

start 
\layout Standard

est l'emplacement mémoire ou l'on souhaite voir crée cette zone.
 Mais attention, ce n'est pas toujours cette adresse qui est prise ! 
\layout Standard

lenght 
\layout Standard

est le nombre d'octets qu'on va allouer.
 
\layout Standard

prot 
\layout Standard

indique les attributs de la zone de projection qu'on va utiliser.
 Ces options sont : 
\layout Standard

PROT_EXEC 
\layout Standard

- On peut exécuter du code dans cette zone mémoire.
 
\layout Standard

PROT_READ 
\layout Standard

- On peut lire le contenu de cette zone.
 
\layout Standard

PROT_WRITE 
\layout Standard

- On peut écrire dans cette zone.
 
\layout Standard

PROT_NONE 
\layout Standard

- Le contenu de la zone est inaccessible.
 (-??-) 
\layout Standard

flags 
\layout Standard

indique le type de projection souhaité.
 Ce peut être : 
\layout Standard

MAP_FIXED 
\layout Standard

- On n'utilise que l'adresse indiqué dans start.
 Si l'emplacement n'est pas disponible, la fonction échoue.
 
\layout Standard

MAP_SHARED 
\layout Standard

- La projection peut être partagée avec d'autres processus.
 
\layout Standard

MAP_PRIVATE 
\layout Standard

- La projection est privée, seul un processus père et ses fils peuvent y
 accéder.
 Les modifications n'affectent pas le fichier (ou périphérique) projeté.
 
\layout Standard

MAP_ANONYMOUS 
\layout Standard

- N'utilise pas de fichier en projection (Non POSIX).
 
\layout Standard

fd 
\layout Standard

est le déscripteur de fichier ou de périphérique à 'mapper' précédemment
 ouvert.
 
\layout Standard

offset 
\layout Standard

est un décalage par rapport au début du fichier ou du périphérique à partir
 duquel va commencer la projection.
 
\layout Standard

Cette fonction renvoie un pointeur sur la zone mémoire si elle réussit,
 -1 avec errno mis à jour dans le cas contraire.
 
\layout Standard

int munmap(void *start, size_t length); 
\layout Standard

Détruit la projection mémoire crée avec mmap().
 
\layout Standard

La fonction renvoie 0 si elle réussit, -1 sinon.
 
\layout Standard

int msync(cont void *start, size_t lenght, int flags); 
\layout Standard

Ecrit sur le disque (ou le périphérique) les modifications qui ont étés
 effectués dans la zone mémoire mappée.
 
\layout Standard

Les structures et les prototypes des fonctions sont accessibles grâce aux
 entêtes unistd.h et sys/mman.h.
 
\layout Standard

Nous allons maintenant voir grâce à mmap comment on peut effectuer des traitemen
t sur un fichier sans nécessiter beaucoup d'accès disque : 
\layout Standard

#include <stdio.h> 
\layout Standard

#include <sys/types.h>
\layout Standard

#include <sys/stat.h>
\layout Standard

#include <fcntl.h>
\layout Standard

#include <unistd.h>
\layout Standard

#include <sys/mman.h>
\layout Standard

#define TAILLE_MEMOIRE 4096
\layout Standard

int main(void)
\layout Standard

{
\layout Standard

int i=TAILLE_MEMOIRE-1;
\layout Standard

char *map,*c;
\layout Standard

int fd;
\layout Standard

if ((fd = open("/tmp/Zobby",O_CREAT | O_RDWR))<0) {
\layout Standard

perror("open");
\layout Standard

exit(-1);
\layout Standard

}
\layout Standard

if (ftruncate(fd,TAILLE_MEMOIRE+1)<0) {
\layout Standard

perror("ftruncate");
\layout Standard

}
\layout Standard

if ((c = map = mmap(0, TAILLE_MEMOIRE, 
\layout Standard

PROT_WRITE, MAP_PRIVATE, fd,0))<0){
\layout Standard

perror("shmat");
\layout Standard

exit(-1);
\layout Standard

} 
\layout Standard

/* Pour l'exemple nous effectuons une modification très simple
\layout Standard

* mais on pourrait imaginer un traitement plus lourd ...
\layout Standard

* dans ce cas, l'utilisation de projections s'avère plus efficace.
 */
\layout Standard

while (i--) {
\layout Standard

c[0] = 'b';
\layout Standard

c++;
\layout Standard

}
\layout Standard

if ((msync(map,TAILLE_MEMOIRE,MS_SYNC))<0) {
\layout Standard

perror("msync");
\layout Standard

}
\layout Standard

if ((munmap(map,TAILLE_MEMOIRE))<0) {
\layout Standard

perror("munmap");
\layout Standard

}
\layout Standard

close(fd);
\layout Standard

return 0;
\layout Standard

}
\the_end
