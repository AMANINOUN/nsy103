<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2014-10-11"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>Langage C</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
Langage C
</h1>
<h2 class="author">
Pascal Fares : ISAE Cnam Liban ©
</h2>
<div class="Right">
pfares@cofares.net
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-I">Part I.</a> Le C
</h1>
<div class="Standard">
Le langage C est un langage de programmation impératif et structuré permettant de définir des programmes pour des applications très diverses. Le langage C est donc un langage de programmation très général. En ce sens il appartient à la famille des langages dits universels comme Algol, Pascal, Ada, etc... La spécificité du langage C vient de sa définition proche d’une structure de machine et de son traitement des pointeurs (adresse mémoire). Il comprend aussi des notions de compilation conditionnelle et de traitement de macro-instruction qui sont essentielles dans la programmation de projet important. La structure interne de la mémoire centrale d’un ordinateur comprend des assemblages fixes de bits et une interprétation de ces regroupements. Ainsi nous avons dans la plupart des cas des octets, des mots et des mots longs. Leur interprétation peut étre caractère, entier, flottant ou pointeur (adresse). Ces éléments fondamentaux sont manipulés par les instructions de la machine; ils formeront les outils de base du langage C. Un programme C se réduit toujours à un ensemble de fonctions non imbriquées. 
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> Les déclarations
</h1>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.None.1">1.None.1</a> La définition des éléments
</h3>
<div class="Standard">
Le langage C est un langage impératif déclaratif. Tout élément doit étre déclaré avant d’étre utilisé. Une seule exception à cette règle concerne les fonctions. Une fonction peut étre déclarée mais elle peut également étre définie par défaut. 
</div>
<div class="Standard">
Chaque nom d’un élement est composé de chiffres ou de lettres et doit commencer par une lettre. Le caractère souligné "_" est considéré comme une lettre. Le nombre de caractères significatifs dépend du compilateur. Historiquement seuls les huit premiers caractères du nom sont pris en considération; les autres caractères sont ignorés (vérifier la documentation du compilateur que vous utilisez). Un nom ne doit pas étre un mot clé; il existe 28 mots clés comme int, static, integer, etc.... 
</div>
<div class="Standard">
Les élements de bases des variables sont au nombre de sept et correspondent aux différentes représentations machines (voir table <a class="Reference" href="#TB">1.None.1↓</a>):
</div>
<div class="Verse">
<table>
<tr>
<td align="center" valign="top">
char
</td>
<td align="center" valign="top">
caractère (octet)
</td>
<td align="center" valign="top">
8 bits
</td>

</tr>
<tr>
<td align="center" valign="top">
short
</td>
<td align="center" valign="top">
entier court signé 
</td>
<td align="center" valign="top">
16 bits
</td>

</tr>
<tr>
<td align="center" valign="top">
int
</td>
<td align="center" valign="top">
entier signé 
</td>
<td align="center" valign="top">
32 bits
</td>

</tr>
<tr>
<td align="center" valign="top">
long
</td>
<td align="center" valign="top">
entier long signé 
</td>
<td align="center" valign="top">
64 bits
</td>

</tr>
<tr>
<td align="center" valign="top">
unsigned 
</td>
<td align="center" valign="top">
entier non signé 
</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="center" valign="top">
float 
</td>
<td align="center" valign="top">
flottant simple précision 
</td>
<td align="center" valign="top">
32 bits
</td>

</tr>
<tr>
<td align="center" valign="top">
double
</td>
<td align="center" valign="top">
flottant double précision
</td>
<td align="center" valign="top">
64 bits
</td>

</tr>

</table>
<br/>
Table des types et leur taille probable <a class="Label" name="TB"> </a>
</div>
<div class="Standard">
Ces éléments représentent les variables élémentaires de la mémoire. Ils correspondent également à une certaine interprétation. La distinction sur la longueur ( nombre de bits ) d’un entier dépend de la machine sur laquelle le langage est implanté. Elle dépend également du compilateur. Le langage précise simplement qu’un entier long est de taille supérieure ou égale à un entier court. Pour les machines à octets un choix fréquent est celui donnée en (Tab <a class="Reference" href="#TB">1.None.1 on page 1↑</a>):
</div>
<div class="Standard">
Char et int sont des variables arithmétiques alors que "float" et "double" sont des variables flottantes. On peut définir des entiers non signés sur toutes les longueurs: 
</div>
<div class="Verse">
unsigned short <br/>
unsigned long. 
</div>
<div class="Standard">
Le langage ne prévoit rien sur la nature signée ou non signée du caractère (octet). Cela dépend de la machine (extension ou non du bit de signe).
</div>
<div class="Standard">
Les constantes associées à ces variables sont définies de manière naturelle: 
</div>
<ul>
<li>
un entier est une suite de chiffres précédée éventuellement d’un signe. 
</li>
<li>
un flottant utilise le point pour commencer la partie décimale et la lettre "e" ou "E" pour l’exposant: +1234.56e-7 
</li>
<li>
un caractère est mis entre apostrophes: ’a’ 
</li>
<li>
certains caractères ne sont pas représentables. On utilise alors une forme spécifique pour déterminer leur code: ’\ddd’ où "ddd" est le code octal du caractère. <br/>
<i>Exemple: ’\014’ est le caractère "form feed" ’\040’ est le caractère espace " "</i> <br/>
Certains caractères sont prédéfinis:<br/>
<b>\n</b> nouvelle ligne ( line feed )<br/>
<b>\t</b> tabulation <br/>
<b>\b</b> espace arière (back space) <br/>
<b>\r</b> retour chariot ( carriage return )<br/>
<b>\f</b> nouvelle forme (form feed ) <br/>
<b>\\</b> caractpre \ <br/>
<b>\’</b> caractère ’ <br/>
Le caractère ’<b>\0</b>’ représente le caractère nul (le nombre 0). 
</li>
<li>
Une constante entière peut étre écrite en octal ou en hexadécimal. Si le premier chiffre d’une constante entière est 0 alors cette constante est en octal ou en hexadécimal. Si le caractère "x" ou "X" suit le 0 alors l’entier est en hezadécimal; sinon il est en octal: <br/>
10  dix en base dix <br/>
012  douze en base huit soit dix en base dix <br/>
OxA  A en base seize soit dix en base dix 
</li>

</ul>
<div class="Standard">
Un pointeur est un entier de type indéfini (dépendant de la machine). On peut définir un pointeur sur n’importe quel élément. Le pointeur représente en fait l’adresse d’une donnée en mémoire.
</div>
<div class="Standard">
Pour déclarer une variable on précise son type puis son nom. Si ce nom est précédé d’une étoile alors la variable est un pointeur sur un élément du type donné: 
</div>
<blockquote class="Quote">
int I; // I est un entier. <br/>
short int I; //I est un entier court. <br/>
int *P; //P est un pointeur sur un entier.
</blockquote>
<div class="Standard">
Une variable peut étre initialisée par une constante ou une expression constante. Cette constante suit la définition de la variable et est placée éventuelleroent entre accolades :
</div>
<blockquote class="Quote">
int k = 2; <br/>
int l = { 3 }; <br/>
int *p = &amp;k; ( adresse de k ). 
</blockquote>
<div class="Standard">
A partir de ces variables élémentaires il existe trois modes de constuction de variables complexes: le tableau, la structure et l’union. 
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.None.1.1">1.None.1.1</a> Le tableau 
</h4>
<div class="Standard">
Un tableau est un ensemble d’éléments de méme type. On définit un tableau par le nombre n de ces éléments et l’indice d’un tableau varie toujours de 0 à n-1: 
</div>
<div class="Verse">
int t[10]; Tableau de 10 entiers 
</div>
<div class="Standard">
Les éléments du tableau sont toujours rangés de maniére consécutive en mémoire et l’index d’adressage doit toujours être une valeur entière. Le nom du tableau est une constante pointeur et représente l’adresse du premier élément du tableau. On pourra ainsi écrire: 
</div>
<div class="Verse">
int *p; <br/>
p = t; affectation à P de l’adresse de t[0], qui est l’adresse du premier élément du tableau 
</div>
<div class="Standard">
Il est bien sûr possible de définir des tableaux à plusieurs dimensions. Dans ce cas les bornes respectives se suivent: 
</div>
<blockquote class="Quote">
int T[10][8]; //tableau à deux dimensions. 
</blockquote>
<div class="Standard">
Le nom du tableau est dans ce cas une constante pointeur sur un tableau:
</div>
<div class="Standard">
int (*P)[8]; P = T; *P est un pointeur et pointe sur le sous-tableau T[0][]. **P est un entier, le premier élément T[0][0]. 
</div>
<div class="Standard">
Remarque: 
</div>
<div class="Standard">
La définition "int **P" serait incorrecte. Elle signifierait pointeur sur un pointeur d’entier et serait donc équivalente à la déclaration "int *P[S]". I1 faut donc définir un pointeur sur un élément du type "T[i]". Cet élément est un tableau de 8 entiers. Les parenthèses de la définition sont donc obligatoires car les crochets sont prioritaires par rapport à l’étoile. 
</div>
<div class="Standard">
Les variations de l’indice dans l’ordre de rangement des éléments du tableau s’effectuent toujours de droite à gauche. 
</div>
<div class="Standard">
Un tableau peut étre initialisé. On définit l’ensemble des valeurs entre deux accolades: 
</div>
<div class="Verse">
int T[10] = { 0,1,2,3,4,5,6,7,8,9 }; <br/>
int S[5][2] = { 0,1 , 2,3 , 4,5 , 6,7 , 8,9 }; variation des indices de droite à gauche. <br/>
ou <br/>
int S[5][2] = { {0,1},{2,3},{4,5},{6,7},{8,9}}; 
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-1"></a>exemple:
</div>
<div class="Verse">
<span class="unknown">\verbatiminput</span>testtab.c
</div>
<div class="Standard">
Un cas particulier de tableau est celui des chaînes de caractères. Une chaine de caractéres est un tableau de caractères à une dimension. I1 existe une forme abrégée pour définir les éléments du tableau d’une chaine de caractères: on place la chaîne entre deux guillemets. Le compilateur construit alors un tableau de caractpres contenant les caractères de la chaine et ajoute le caractère ’\0" en fin de tableau. Les deux déclarations suivantes ont le même effet: 
</div>
<div class="Verse">
char CH[3] = { ’u’,’n’,’\0’ }; <br/>
char CH[3) = "un"; 
</div>
<div class="Description">
<span class="Description-entry">Remarque:</span> Le termanateur de chaîne (’\0’) est utilisé pour reconnaître la fin d’une chaîne, son absence est grâve des fonctions tel que <tt><b>printf</b></tt> ne saurait plus fonctionner.
</div>
<div class="Standard">
Bien sûr un tableau est une constante pointeur. On pourra définir plus simplement la chaine comme: 
</div>
<div class="Verse">
char *CH=&rdquo;un&rdquo;;<br/>
ou<br/>
char CH[] = "un";
</div>
<div class="Standard">
La définition d’une table de messages pourra prendre la forme d’une table de pointeurs sur des chaines de caractpres : 
</div>
<div class="Verse">
char *MES[3] = { "messagel","message2","message3" }; 
</div>
<div class="Standard">
cette définition correspond 8 la définition: 
</div>
<pre class="LyX-Code">
char MES1[]="message1"; //premier tableau contenant "messagel" 
char MES2[] = "message2"; 
char MES3[] = "message3"; 
char *MES[3] = { MESl, MES2, MES3 }; 
/** Les éléments de ce tableau sont des
  * pointeurs sur des caractères. Ils
  * peuvent étre initialisés avec les
  * constantes pointeurs MESl, MES2 et
  * MES3.
  */ 
</pre>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.None.1.2">1.None.1.2</a> La structure 
</h4>
<div class="Standard">
La structure est un ensemble hétérogène d’éléments regroupés pour des raisons fonctionnelles. Une structure porte un nom qui identifie sa nature. Ce nom pourra servir à la définition de plusieurs variables de ce type. Une structure est introduite par le mot clé "struct" suivi du nom d’identification et enfin, entre accolades, de la description des éléments composant cette structure: 
</div>
<pre class="LyX-Code">
struct exp { 
    int I; 
    int *P; 
    int TAB[10]; 
}; 
La structure "exp" est composée d’un entier, d’un pointeur sur un entier et d’un tableau de dix entiers. 
</pre>
<div class="Standard">
La déclaration d’une structure ne définit aucune variable. Elle définit seulement la forme d’une structure et identifie cette forme par un nom. Dans l’exemple précédent la forme de cette structure porte le nom "exp". On peut alors définir des variables ayant cette forme: 
</div>
<pre class="LyX-Code">
struct exp A, *B, C[10]; 
A est une structure de type "exp". 
B est un pointeur sur une structure de type "exp". 
C est un tableau de dix structures de type "exp". 
</pre>
<div class="Standard">
L’initialisation d’une structure est similaire à l’initialisation d’un tableau. Les éléments sont rangés de gauche à droite ou de haut en bas:
</div>
<pre class="LyX-Code">
struct dex { 
    int I; 
    char A; 
    short C[4]; 
}; 
struct dex E = { 2,’a’,3,4,5,6 }; 
</pre>
<div class="Standard">
La déclaration d’une variable structure peut suivre directement la définition de type: 
</div>
<pre class="LyX-Code">
struct trx { 
    int T[10]; 
    char L[S]; 
} F; /* définit une structure F de type trx. */

</pre>
<div class="Standard">
Les structures peuvent étre imbriquées. 
</div>
<div class="Standard">
On réfère à un élément d’une structure par le nom pointé: 
</div>
<pre class="LyX-Code">
E.I représente l’élément I de la structure E de type dex. F.L[0] ou F.(L[0]) représente le premier élément du tableau L de la structure F de type trx. 
</pre>
<div class="Standard">
Dans le cas ou il s’agit d’un pointeur sur une structure il faut utiliser le nom fléché "-&gt;" ( symbole "-" suivi du symbole "&gt;" ): 
</div>
<pre class="LyX-Code">
B-&gt;I représente l’élément I de la structure pointée par B. 
</pre>
<div class="Standard">
Ces expressions peuvent étre d’une complexité quelconque ( limites imposées par le compilateur ). 
</div>
<pre class="LyX-Code">
struct cexp { 
    struct exp K[10]; 
    int A; 
    struct exp *V; 
}; 
struct cexp L,*R; 
</pre>
<div class="Standard">
On peut alors avoir par exemple les constructions suivantes: 
</div>
<pre class="LyX-Code">
L.K[0].TAB[1]   deuxième élément du tableau "TAB" de la
                structure premier élément du tableau K 
                de la structure L.

R-&gt;K[1].I       variable I de la structure deuxième élément du tableau K dans la structure pointée par R. 
*(L.V-&gt;P) valeur de la variable pointée par le pointeur P de la structure pointé par la variable V de la structure L
R-&gt;V-&gt;P variable P de la structure pointée par la variable V de la structure pointée par la variable R. 
</pre>
<div class="Standard">
Un cas particulier concerne les structures se référant à elles-mémes (type récursif): 
</div>
<pre class="LyX-Code">
struct cel { 
    int R; 
    struct cel *Suivant; 
}; 
</pre>
<div class="Standard">
Ce type de structure permet de définir des listes de façon simple. Une cellule d’une liste du type précédent est constituée d’un entier et d’un pointeur sur la cellule suivante. 
</div>
<div class="Standard">
La structure suivante permet la définition d’un arbre binaire: 
</div>
<pre class="LyX-Code">
struct bin { 
    int val; 
    struct bin *gauche; 
    struct bin *droite; 
}; 
</pre>
<div class="Standard">
La construction de type structure sert également à définir des champs. Un champ est une suite continue de bits. Les champs doivent tous être définis à l’intérieur d’une variable élémentaire. Les bits de cette variable sont pris dans le même ordre mais le langage ne précise pas cet ordre (gauche-droite ou droite-gauche). Nous supposerons pour les exemples que l’on utilise l’ordre gauche-droite. Un champ est défini en précisant le nombre de bits qu’il contieni: 
</div>
<pre class="LyX-Code">
struct champ { 
    unsigned prem : 4; /* les quatre premiers bits. */
    unsigned deux : 2; /* les deux bits suivants.   */
    unsigned fin : 16; /* et les 16 derniers        */
};
</pre>
<div class="Standard">
Une structure de ce type fait référence à 32 bits (regroupement minimum existant pour contenir les trois champs ). Cette structure sera donc rangée dans un mot de 32 bits sur une machine classique. Dans le cas ou un int sur cette machine occupe 32 bits la structure sera rangée dans un "int". Dans le cas ou les "int" de cette machine serait aeulement de 16 bits cette structure serait rangée dans un tableau de deus "int": Le premier mot contiendrait les deux premiers champs et le deuxième mot le champ suivant. I1 ne doit pas y avoir de chevauchement entre les données élémentaires pour les champs ). Un champ peut ne pas Atre nommé; dans ce cas on utilise les deux poinis suivis de la largeur du champ anonyme. Ils sont utilisés pour le remplissage. Ainsi dans le cas précédent et en supposant qu’un int occupe 16 bits la structure champ est équivalente H la structure: 
</div>
<pre class="LyX-Code">
struct champ { 
    unsigned prem: 4; 
    unsigned deux: 2; 
    : 10; 
    unsigned fin: 16; 
};
</pre>
<div class="Standard">
Les champs sont des entiers. I1s peuvent étre utilisés comme tel. 
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.None.1.3">1.None.1.3</a> L’Union 
</h4>
<div class="Standard">
La mémoire est une suite de bits avec certains regroupements. Les regroupements peuvent étre interprétés de différentes façons. Ainsi un octet peut étre interprété comme un entier ou comme un caractère. Seul l’utilisation du regroupement détermine l’interprétation machine de ce regroupement. Les langages de programmations associent des noms à ces regroupements et définissent une interprétation par 1e type. Cette interprétation fixe associée à un regroupement peut étre quelquefois source de difficultés inexistantes dans la programmation assembleur. La définition d’union permet de définir une vision différente du méme espace mémoire. Les contraintes dues aux types sont donc ainsi levées. La définition d’une union suit le méme principe que celui d’une siructure mais chaque membre définit une interprétation du méme espace mémoire:
</div>
<pre class="LyX-Code">
union exp { 
    int I; 
    char T[2];
}
</pre>
<div class="Standard">
Si un entier est sur 16 bits et un caractère sur 8 bits 1a définition précédente donnera deux interprétations de 16 bits mémoire: soit une suite de deux caractères, soit un entier signé. Les règles de traitement de l’union sont les mémes que celle de la structure. La zone mémoire occupée par une union est toujours la zone maximum correspondant à l’un de ces membres. 
</div>
<div class="Standard">
Exemple: Un registre sur le micoprocesseur 68000 possède 32 bits. I1 peut étre utilisé sur 16 bits et sur 8 bits. On peut définir toutes les interprétations d’un registre: 
</div>
<pre class="LyX-Code">
traitement des bits: 
struct bitrg { 
unsigned bit3l:l; unsigned bit30:1; unsigned bit29:1; unsigned bit28:1; unsigned bit27:1; unsigned bit26:1; unsigned bit25:1; unsigned bit24:1; unsigned bit23:1; unsigned bit22:1; unsigned bit2l:l; unsigned bit20:1; unsigned bitl9:l; unsigned bitl8:l; unsigned bitl7:l; unsigned bitl6:l; unsigned bitl5:l; unsigned bitl4:l; unsigned bitl3:l; unsigned bitl2:l; unsigned bitll:l; unsigned bitl0:l; unsigned bit09:1; unsigned bit08:1; unsigned bit07:1; unsigned bit06:1; unsigned bit05:1; unsigned bit04:1; unsigned bit03:1; unsigned bit02:1; unsigned bit0l:l; unsigned bit 00:1 }; 

Définition du registre: 

union reg { 
    struct bitrg H; 
    char CR[4]; 
    short SR[2]; 
    long LR; 
}; 

ainsi avec la déclaration "struct reg R"; 

R.B.bit31 représentera le bit de poids fort. 
R.CR[3] le caractère manipulé dans les instructions
        machines. 
R.SR[2] le mot traité par les instructions machines. 
R.LR le mot long ou le registre en entier. 

</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.None.2">1.None.2</a> La déclaration des fonctions 
</h3>
<div class="Standard">
I1 ne faut pas confondre la <i>définition d’une fonction</i> et sa <i>déclaration</i>. La déclaration indique le nom de cette fonction et précise la nature du résultat de cette fonction. 
</div>
<div class="Standard">
Dans le langage C toutes les fonctions produisent un résultat. L’utilisation d’un résultat n’est pas obligatoire et une procédure peut étre vue comme une fonction dont on utilise pas le résultat. Dans le langage C la déclaration des fonctions ne donne aucune indication sur les paramètres ( nombre et nature ) qui doivent être passés à cette fonction. Les paramètres seront définis seulement au moment de la définition de la fonction. La cohérence entre la nature des paramètres à l’appel d’une fonction et celle attendue par la fonction est de la responsabilité du programmeur. I1 existe des programmes ( lint ) qui permettent de vérifier cette cohérence.
</div>
<div class="Standard">
de même le compilateur gcc de GNU augmente C de la possibilité de signer les fonctions, il permet de préciser les paramètre et leurs type au moment de la déclaration. La norme initiale du langage C imposait qu’un paramètre soit de nature simple ( contenu dans un mot mémoire ). Les versions actuelles acceptent des extensions et permettent de passer une structure comme paramètre ( dans la norme initiale il était seulement possible de passer un pointeur sur une structure, ce qui reste meilleur car consomme mois de place dans la pile). La même contrainte existe sur la nature de l’objet retourné par une fonction. Ces restrictions initiales ne sont pas des limitations car comme il est possible de transmettre dans les deux sens des pointeurs sur des objets des objets ( le programme appelant ou appelé doit simplement comporter une recopie de l’objet pointé ). <i>Ce paragraphe ne traite que de la déclaration des fonctions</i>. Une fonction définit une valeur d’un objet quelconque. On définit une fonction en plaçant deux parenthèses derrière son nom. La fonction doit étre précédée du type d’objet qu’elle produit:
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-2"></a>un exemple:
</div>
<div class="Standard">

</div>
<pre>
int f(); /* signature d'une fonction renvoyant un entier */

int *g(); /* signature d'une fonction renvoyant un pointeur sur entier */

int w();
int (*k)(); /* pointeur sue une fonction renvoyant un entier */

/**
  * definition de la fonction f
  */
int f(int x, int y) {
    return (x+y);
}

int w(int (*s)(), int x, int y) {
   return ((*s)(x,y));
   /* dans gnu gcc on peur ecrite s(x,y) au lieu (*s)(x+y)
    * c'est peut-être plus clair!
    */
}

main () {
 k=f; /* on dit que k pointe sur la fonction f */

 printf("%d+%d=%d\n",3,5,k(3,5)); 
     /* l'utilisation de k est alors equivalente à f*/
 printf("%d+%d=%d\n",3,5,w(f,3,5)); 
}

/** resultat de l'execution (test)
compilation:
[pfares@pportable MPS]$ gcc testdecfonc.c
execution:
[pfares@pportable MPS]$ ./a.out
3+5=8
3+5=8
*/

</pre>
<pre class="LyX-Code">
int f(); //fonction renvoyant un entier. 
int *f(); //fonction renvoyant un pointeur sur un entier. 
int (*f)(); pointeur sur une fonction renvoyant un entier.
            La parenthèse est ici nécessaire. Elle précise
            que l’étoile se rapporte à "f" et non à "int".
            Donc au lieu d’avoir un pointeur sur "int" on a
            un pointeur sur "f". 
int *(*f)(); pointeur sur une fonction renvoyant un pointeur
             sur un entier. 
struct exp *f(); fonction renvoyant un pointeur sur une
                 structure de type "exp". 
</pre>
<div class="Standard">
Avec une fonction il est possible soit de l’appeler, soit de caluler son adresse. 
</div>
<div class="Standard">
Lorsqu’une fonction n’est pas déclarée elle retourne implicitement un entier. Lorsque l’on veut définir une procédure on définit une fonction et on n’utilise pas sa valeur. Certains compilateurs utilisent le type <tt><b><u>"void"</u></b></tt> pour indiquer que la valeur de la fonction ne doit pas étre utilisée. 
</div>
<div class="Standard">
Exemple de définition de fonctions: 
</div>
<div class="Verse">
Soit une fonction "somme" qui retourne la somme de deux éléments. Les écritures suivantes ont le méme effet:
</div>
<pre class="LyX-Code">
x + y;      évaluation de la somme 
somme(x,y); sans utilisation du résultat. 
z = x + y;      évaluation de la somme 
z = somme(x,y); avec utilisation du résultat.
</pre>
<div class="Standard">
Lorsque l’on fait référence à une fonction comme paramètre d’une autre fonction on utilise implicitement son adresse: 
</div>
<pre class="LyX-Code">
int f(); 
g(f); 
</pre>
<div class="Standard">
Dans g() on définit le paramètre comme un pointeur sur une fonction:
</div>
<pre class="LyX-Code">
g(P) 
int (*p)(); 
{ ....
   (*p)(); appel de la fonction paramètre.
   ....
} 
</pre>
<div class="Standard">
Bien sûr les pointeurs sur des fonctions peuvent apparaitre n’importe où comme membre d’une structure ou élément de tableau. 
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-3"></a>Exemple:
</div>
<div class="Standard">
Sur le microprocesseur 68000 il existe un tableau de vecteurs d’interruptions. Ce tableau définit pour chaque entrée une procédure d’exception. Nous pouvons le déclarer de la façon suivante: 
</div>
<pre class="LyX-Code">
   int (*exp)()[256]; 
ou
   void (*exp)()[256]; 
</pre>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--1"></a>La déclaration de type : typedef 
</h3>
<div class="Standard">
La pseudo-fonction "typedef" permet la définition de nouveau type. Elle est très utile pour les programmes importants. Cette fonction ne définit qu’une abzéviation et n’est pas associée à la définition du traitement du type cozrespondant comme dans le langage ADA ou C++ par exemple. Néanmoins elle est très employée dans les programmes volumineux et permet de classifier les différents objets utilisés ( un nom par type d’objet ). Le mot clé "typedef" précède la déclaration:
</div>
<pre class="LyX-Code">
typedef int Now; Le mot "Now" devient un type nouveau
                 synonyme de "int". 
</pre>
<div class="Standard">
On pourra alors écrire:
</div>
<pre class="LyX-Code">
Now x,y; x et y sont deux entiers. 
</pre>
<div class="Standard">
Bien sûr cette pseudo-fonction est valable quelle que soit la déclaration: 
</div>
<pre class="LyX-Code">
typedef struct { 
    char NOM[8]; 
    int IX; 
} TAB; 
</pre>
<div class="Standard">
Le mot "TAB" définit un type d’élément qui peut étre utilisé pour former de nouveaux objets:
</div>
<pre class="LyX-Code">
TAB T[100],*P: tableau de structure et pointeur sur une
               structure.
T[4].IX détinit l’entier IX de 1a structure en cinquième
        position dans le tableau T. 
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-1.1">1.1</a> Les expressions 
</h2>
<div class="Standard">
Une expression définit une valeur. La valeur d’une expression esi très souvent une valeur élémentaire ( dans la norme initiale une expression définit toujours une valeur élémentaire ). Pour définir une expression on utilise des variables, des constantes et des opérateurs. Une fonction est bien sdr considérée comme un opérateur. Ces opérateurs permettent de calculer une nouvelle valeur à partir d’un ensemble d’éléments. 
</div>
<div class="Description">
<span class="Description-entry">Exemple:</span> L’opérateur "&amp;" détermine l’adresse de quelque chose. "&amp;I" sera donc l’adresse de la variable I. 
</div>
<div class="Standard">
L’accès à une valeur élémentaire détermine une expression primaire. Une expression primaire utilise des opérateurs d’accés et est définie par: 
</div>
<ul>
<li>
une constante. 
</li>
<li>
un identificateur. 
</li>
<li>
une chaine. 
</li>
<li>
une expression entre parenthèses.
</li>
<li>
une expression primaire suivie d’une expression enire crochets. 
</li>
<li>
une expression primaire suivie d’une suite d’expressions entre parenthpses. 
</li>
<li>
une valeur primaire suivie d’un identificateur précédé d’un point.
</li>
<li>
une expression primaire suivie d’un identificateur précédé d’une flèche. 
</li>

</ul>
<div class="Standard">
Dans chaque cas la signification est différente. Elle correspond l’interprétation suivante: 
</div>
<ul>
<li>
[<span class="formula">≜</span>] constante : constante. 
</li>
<li>
[<span class="formula">≜</span>] identificateur : valeur de la variable définie par cet identificateur. 
</li>
<li>
[<span class="formula">≜</span>]chaine : une chaine est un tableau de caractères. La valeur associée à une chaine est donc un pointeur sur le premier caractère de la chaine. 
</li>
<li>
[<span class="formula">≜</span>]( expression ) : valeur de l’expression.
</li>
<li>
[<span class="formula">≜</span>]expression_primaire [ expression ] : accès à un tableau. l’expression E1[E2] à la méme signification que *((E1) + (E2))
</li>
<li>
[<span class="formula">≜</span>]expression_primaire(liste d’expression) : appel de fonction. 
</li>
<li>
[<span class="formula">≜</span>] valeur_primaire.identificateur : accès à un élément de structure. 
</li>
<li>
[<span class="formula">≜</span>] expression_primaire-&gt;identificateur : accès à un élément d’une structure pointée. 
</li>

</ul>
<div class="Standard">
L’évaluation d’une expression utilise toujours les mémes formes de données. I1 y a une conversion préalable (casting) avant toute évaluation. Cette conversion suit des règles simples: 
</div>
<ul>
<li>
[<span class="formula">✓</span>]Les opérandes de type caractère et entier court sont converties en entiers. 
</li>
<li>
[<span class="formula">✓</span>] Les opérandes de type flottant sont converties en double. 
</li>
<li>
[<span class="formula">✓</span>] Si une opérande est de type double, les autres opérandes du mème opérateur sont converties en double. 
</li>
<li>
[<span class="formula">✓</span>] Sinon si une opérande est de type long, les sutres opérandes sont converties en long. 
</li>
<li>
[<span class="formula">✓</span>] Sinon si une opérande est de type unsigned, les autres opérandes sont converties en unsigned. 
</li>
<li>
[<span class="formula">✓</span>] Sinon les opérandes sont de type int. 
</li>

</ul>
<div class="Standard">
Le résultat de l’expression est du type ainsi déterminé et peut étre converti pour une affectation par exemple. Les différents opérateurs accessibles dans le langage C sont les suivants:
</div>
<div class="Standard">
<table>
<tr>
<td align="left" valign="top">
<b>Les opération arithmétique</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
-
</td>
<td align="center" valign="top">
mois ou opposé
</td>
<td align="justify" valign="top" style="width: 40mm;">
-2 ou 3 - 5
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
+
</td>
<td align="center" valign="top">
plus
</td>
<td align="justify" valign="top" style="width: 40mm;">
5+8
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
*
</td>
<td align="center" valign="top">
multiplier
</td>
<td align="justify" valign="top" style="width: 40mm;">
5*8
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
/
</td>
<td align="center" valign="top">
division
</td>
<td align="justify" valign="top" style="width: 40mm;">
5/2 <span class="formula">≜</span> (2)
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
%
</td>
<td align="center" valign="top">
reste ou modulo
</td>
<td align="justify" valign="top" style="width: 40mm;">
5%2<span class="formula">≜</span>  1
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateurs booléens</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">
<i>bit à bit</i>
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
~
</td>
<td align="center" valign="top">
compléments
</td>
<td align="justify" valign="top" style="width: 40mm;">
~0<span class="formula">≜</span> 255
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
|
</td>
<td align="center" valign="top">
union
</td>
<td align="justify" valign="top" style="width: 40mm;">
0x0f|0xf0 <span class="formula">≜</span>0xff
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
^
</td>
<td align="center" valign="top">
union exlusive
</td>
<td align="justify" valign="top" style="width: 40mm;">
0xff^0xff\triangleq 0x00
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&amp;
</td>
<td align="center" valign="top">
intersection
</td>
<td align="justify" valign="top" style="width: 40mm;">
0x0f&amp;0xf0\triangleq0x00
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateurs de décalage</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&gt;&gt;
</td>
<td align="center" valign="top">
décalage droit
</td>
<td align="justify" valign="top" style="width: 40mm;">
111000&gt;&gt;2<span class="formula">≜</span>001110
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&lt;&lt;
</td>
<td align="center" valign="top">
décalage gauche
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateurs logiques</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
!
</td>
<td align="center" valign="top">
non
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
!=
</td>
<td align="center" valign="top">
différent
</td>
<td align="justify" valign="top" style="width: 40mm;">
3!=2 <span class="formula">≜</span>vrai
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&lt;
</td>
<td align="center" valign="top">
inférieur
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&lt;=
</td>
<td align="center" valign="top">
inférieur ou égal
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&gt;
</td>
<td align="center" valign="top">
supérieur
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&gt;=
</td>
<td align="center" valign="top">
supérieur ou égal
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&amp;&amp;
</td>
<td align="center" valign="top">
et
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
||
</td>
<td align="center" valign="top">
ou
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateur d’affectation</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">
changement de l’état mémoir
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
=
</td>
<td align="center" valign="top">
affectation
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
+=
</td>
<td align="center" valign="top">
ajout afectation
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x+=2<span class="formula"> → </span>x<span class="formula">≜</span>3
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
-=
</td>
<td align="center" valign="top">
soustraire
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x-=2<span class="formula"> → </span>x<span class="formula">≜</span>-1
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
*=
</td>
<td align="center" valign="top">
multiplier
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x*=2<span class="formula"> → </span>x<span class="formula">≜</span>2
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
/=
</td>
<td align="center" valign="top">
diviser
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x/=2<span class="formula"> → </span>x<span class="formula">≜</span>0
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
%=
</td>
<td align="center" valign="top">
reste
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x%=2<span class="formula"> → </span>x<span class="formula">≜</span>1
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&gt;&gt;=
</td>
<td align="center" valign="top">
decaler droite
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>32,x&gt;&gt;=2<span class="formula"> → </span>x<span class="formula">≜</span>8
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&lt;&lt;=
</td>
<td align="center" valign="top">
decaler gauche
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x&lt;&lt;=2<span class="formula"> → </span>x<span class="formula">≜</span>4
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&amp;=
</td>
<td align="center" valign="top">
et binaire
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x&amp;=2<span class="formula"> → </span>x<span class="formula">≜</span>0
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
|=
</td>
<td align="center" valign="top">
ou binaire
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x|=2<span class="formula"> → </span>x<span class="formula">≜</span>3
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
^=
</td>
<td align="center" valign="top">
xor binaire
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,x+=2<span class="formula"> → </span>x<span class="formula">≜</span>3
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateur d’incrémentation</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
++exp
</td>
<td align="center" valign="top">
pré-incrémentation
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,y = ++x<span class="formula"> → </span>x=2,y=2
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
exp++
</td>
<td align="center" valign="top">
post-incrémentation
</td>
<td align="justify" valign="top" style="width: 40mm;">
x<span class="formula">≜</span>1,y = x++<span class="formula"> → </span>x<span class="formula">≜</span>2,y<span class="formula">≜</span>1
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
--exp
</td>
<td align="center" valign="top">
pré-décrémentation
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
exp--
</td>
<td align="center" valign="top">
post-incrémentation
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateur calcul d’adresse</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
&amp;
</td>
<td align="center" valign="top">
adresse de
</td>
<td align="justify" valign="top" style="width: 40mm;">
y<span class="formula">≜</span>1,x=&amp;y
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateur d’accés</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
*
</td>
<td align="center" valign="top">
valeur dont l’adresse est
</td>
<td align="justify" valign="top" style="width: 40mm;">
*x<span class="formula">≜</span>1
</td>

</tr>
<tr>
<td align="left" valign="top">
Opérateur de taille
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
sizeof
</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">
sizeof(int)<span class="formula">≜</span>2
</td>

</tr>
<tr>
<td align="left" valign="top">
Opérateur de type
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">
casting
</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
(type)
</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
<b>Opérateur eval en séquence</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
,
</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">
y=(x=1,x=x+2)<span class="formula"> → </span>y<span class="formula">≜</span>3,x<span class="formula">≜</span>3
</td>

</tr>
<tr>
<td align="left" valign="top">
<b>opérateur conditionel</b>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top">
e0 ? e1 : e2
</td>
<td align="center" valign="top">

</td>
<td align="justify" valign="top" style="width: 40mm;">
(2&gt;1?’a’:’b’)<span class="formula">≜</span>’a’
</td>

</tr>

</table>

</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-4"></a>Les booléens en C
</div>
<div class="Standard">
Il n’y a pas de booléen au sens propre du terme en C, par contre toute valeur numérique nulle est considérée fausse et toute valeur non nulle est considérée vraie
</div>
<div class="Description">
<span class="Description-entry">Exemple</span> 
</div>
<div class="Standard">

</div>
<pre>
main () {
   int x=0;
   int y=-1;

   if (x) printf("x vrai\n");
   else  printf("x faux\n");
   if (y) printf("y vrai\n");
   else  printf("y faux\n");
}

/** résultat de l'execution
 gcc bool.c 
[pfares@pportable MPS]$ ./a.out 
x faux
y vrai
*/


</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-1.2">1.2</a> Le calcul sur les pointeurs
</h2>
<div class="Standard">
Les pointeurs sont de type "int" avec quelques nuances. Par contre on peut ajouter ou retrancher un entier à un pointeur. De même si l’on retranche deux pointeurs on obtient un entier. Ce sont les seules combinaisons permises. Lorsque l’on ajoute ou l’on retranche un entier à un pointeur l’opération s’effectue relativement à la dimension ( en octets ) de l’objet sur lequel le pointeur pointe. Cela correspond à un déplacement dans un tableau d’éléments de même type:
</div>
<pre class="LyX-Code">
struct A 
{ 
    long K; 
    long L;
} T[10],*P;
</pre>
<div class="Standard">
Chaque élément de T à 8 octets. Lorsque l’on ajoute 1 au pointeur P on lui ajoute en fait 8 :
</div>
<pre class="LyX-Code">
char *C; P = T;
C = (char *) P;
</pre>
<div class="Standard">
Après les deux affectations suivantes les pointeurs P et C auront la même valeur:
</div>
<pre class="LyX-Code">
++P; C += 8;
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-1.3">1.3</a> Les structures de contrôle
</h2>
<div class="Standard">
Le langage C possède une structure de blocs. Ces blocs permettent de définir un programme structuré. Plusieurs instructions permettent le traitement d’une instruction complexe ou d’un bloc. Ces instructions sont celles que l’on retouve plus ou moins dans tout langage structuré.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.1">1.3.1</a> Le bloc
</h3>
<div class="Standard">
Un bloc est délimité par deux accolades. Il permet la définition de variables locales au bloc et elles sont déclarées dès le début de bloc. Ces variables cachent éventuellement la visibilité de variables appartenant à des blocs supérieurs. Un bloc constitue une instruction.
</div>
<div class="Standard">
Exemple:
</div>
<pre class="LyX-Code">
{
    int I,J; /* premier bloc. 
              * Ce bloc contient deux variables 
              * locales I et J.
              */
    {
        int I; /* bloc imbriqué. 
                * Ce bloc comporte une déclaration d’une
                * variable locale I qui occulte la première
                * variable locale I. 
                * Dans ce bloc on accède 
                * donc au deuxième I et sur J bien sûr
                *
    } 
    ........
    /* on accède de nouveau au premier I 
     */
}
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.2">1.3.2</a> La structure if-else
</h3>
<div class="Standard">
Cette structure classique prend la forme:
</div>
<pre class="LyX-Code">
if ( expression ) &lt;instructionV&gt;else &lt;instructionF&gt;
</pre>
<div class="Standard">
L’expression est évaluée et si elle est non nulle on applique l’instructionV. Sinon on applique l’instructionF.
</div>
<div class="Standard">
Lorsque plusieurs "if" sont imbriqués un "else" est toujours associé à l’"if" sans "else" le plus près. C’est à dire le dernier qui précède ce "else".
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
if (n &gt; 0) if (a &gt; b)
</div>
<div class="Standard">
z = a; else z = b;
</div>
<div class="Standard">
Le "else" se rapporte au "if" de la condition "a&gt;b". Cette instruction peut définir un choix multiple :
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.3">1.3.3</a> 1.3.3 La structure switch
</h3>
<div class="Standard">
Cette instruction permet un choix multiple. Ici une expression est évaluée et sa valeur détermine l’endroit du programme où l’on doit commencer l’exécution. Sa forme générale est la suivante:
</div>
<pre class="LyX-Code">
switch ( expression) {
    case val_1 : instruction
    case val_n : instruction
    default : instruction
}
</pre>
<div class="Standard">
I1 faut remarquer plusieurs conventions à propos de cette instruction "switch":
</div>
<ul>
<li>
La valeur de l’expression doit être de type "int". Toutes les valeurs associées aux différents cas sont des constantes converties en "int".
</li>
<li>
La valeur de l’expression est comparée à chaque cas et le premier ayant la valeur de l’expression détermine le point de départ de l’exécution qui se déroule ensuite en séquence jusqu’à la fin de l’instruction "switch".
</li>
<li>
La constante "default" permet de définir un point d’entrée quelle que soit la valeur de l’expression de façons à avoir des traitements mutuellement explusifs.
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.4">1.3.4</a> L’instruction while
</h3>
<div class="Standard">
Cette instruction de boucle permet de répéter une instruction tant qu’une condition est vérifiée:
</div>
<pre class="LyX-Code">
while ( expression ) instruction
</pre>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
Lecture d’un mot séparé par un blanc avec conservation des huit premiers caractères:
</div>
<pre class="LyX-Code">
int i = 0;
while((c = getchar()) != ’ ’) if (I &lt; 8) NOM[i++] = c;
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.5">1.3.5</a> L’instruction do-while
</h3>
<div class="Standard">
Cette instruction est similaire à la précédente. Dans le cas de l’instruction précédente le test est d’abord effectué et par conséquent l’instruction peut ne jamais être exécutée. Dans le cas de cette instruction le test est réalisé après l’exécution de l’instruction qui est donc toujours effectuée au moins une fois.
</div>
<pre class="LyX-Code">
do &lt;instruction&gt; while( expression );
</pre>
<div class="Standard">
est équivalent à:
</div>
<pre class="LyX-Code">
instruction 
WhilE( expression) instruction
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.6">1.3.6</a> L’instruction for
</h3>
<div class="Standard">
Cette dernière instruction de boucle du langage C possède trois composantes: l’initialisation, le test et la progression. Sa forme est la suivante:
</div>
<pre class="LyX-Code">
for( expression~l; expression~2; expression~3) instruction
</pre>
<div class="Standard">
Cette instruction est équivalente à la suite:
</div>
<pre class="LyX-Code">
expression~l while(expression~2) {
    instruction 
    expression~3;
}
</pre>
<div class="Standard">
Chaque expression est facultative mais dans ce cas on doit laisser les points virgules. Lorsque l’expression 2 est absente elle est réputée vraie par convention ( jamais nulle ).
</div>
<div class="Standard">
Exemple:
</div>
<pre class="LyX-Code">
boucle infinie: for(;;) instruction
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.7">1.3.7</a> L’instruction break
</h3>
<div class="Standard">
Cette instruction arrête l’exécution d’une instruction "while", "dowhile", "for" ou "switch". Cet arrêt concerne l’instruction la plus interne lorsque plusieurs de celles-ci sont imbriquées.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
Recherche dans une table d’un mot de huit caractères :
</div>
<pre class="LyX-Code">
{
char T[100][8],NOM[8]; 
int I,J;
for(I = 0; I &lt; 100; ++I) 
    for(J = 0; J &lt; 8; ++J)
        if (T[I][J] != NOM[J]) break; 
        if (J == 8) break;
}
</pre>
<div class="Standard">
Le premier "break" arréte la comparaison des mots dès qu’il y a deux caractères différents entre le mot de la table et le mot recherché.
</div>
<div class="Standard">
Le deuxième "break" arrête la recherche dans la table dès que le mot a été trouvé. I1 a été trouvé lorsque J est égal à 8 et donc lorsque la boucle interne ne s’est pas arrétée sur le "break".
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.8">1.3.8</a> L’instruction continue
</h3>
<div class="Standard">
Cette instruction définie une nouvelle itération d’une boucle "while" .
</div>
<div class="Standard">
"do-while" ou "for". Elle est équivalente à une instruction "goto" ver la fin de boucle. Elle est équivalente à l’instruction "goto contin;" dans les cas suivants:
</div>
<div class="Standard">
while( expression ) do for(.......) contin: ; contin: ; contin: ;
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.9">1.3.9</a> L’instruction goto
</h3>
<div class="Standard">
Le langage C possède bien évidemment une instruction de saut. Elle es rédu.ite à sa plus simple expression. Chaque instruction peut ét= identifiée par une étiquette et l’instruction "goto" fait référence l’une de ces étiquettes:
</div>
<div class="Standard">
goto etiquette;
</div>
<div class="Standard">
Une étiquette est un identificateur placé devant une instruction:
</div>
<div class="Standard">
etiquette : instruction
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.3.10">1.3.10</a> L’instruction vide
</h3>
<div class="Standard">
Une instruction peut être nulle, c’est à dire vide. Elle peut servir définir un corps de boucle nul par exemple, ou à positionner une étiquette.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
boucle d’attente d’interruption:
</div>
<pre class="LyX-Code">
for(;;) ;
</pre>
<div class="Standard">
boucle infinie où il n’y a rien à faire.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.4">1.4</a> 4 Les fonctions et la notion de classes
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.4.1">1.4.1</a> Les fonctions
</h3>
<div class="Standard">
Une fonction C est un bloc définissant une valeur. Ce bloc possède des paramétres d’appels et un type identifiant la nature de l’élément produit.
</div>
<div class="Standard">
Une fonction a la forme suivante:
</div>
<pre class="LyX-Code">
type &lt;nom de la fonction&gt; ( &lt;liste des paramètres&gt; ) 
description des paramètres
{
    &lt;corps de la fonction&gt;
}
</pre>
<div class="Standard">
üne fonction produit une valeur qui est définie par l’instruction "return". Si cette instruction n’est pas présente ou si elle ne définit pas de valeur la valeur de la fonction est indéfinie ( mais elle existe ).
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.4.1.1">1.4.1.1</a> L’instruction retum
</h4>
<div class="Standard">
L’instruction "return" permet de définir la valeur de la fonction. cette instruction à la forme suivante:
</div>
<pre class="LyX-Code">
   return expression ;
ou
   return ;
</pre>
<div class="Standard">
La valeur de l’expression est convertie dans le type de la fonction. Dans le cas de l’expression vide la valeur transmise est indéfinie.
</div>
<div class="Standard">
Exemple:
</div>
<pre class="LyX-Code">
int max(a,b) 
int a,b;
{
    return a&gt;b?a:b; 
}
</pre>
<div class="Standard">
Cette fonction retourne la valeur maximum des paramètres a et b.
</div>
<div class="Standard">
les paramètres
</div>
<div class="Standard">
Une particularité du langage C réside dans son mode d’appel des fonctions:
</div>
<ul>
<li>
Tout paramètre est appelé par valeur.
</li>
<li>
Les paramètres sont en général simples ( obligatoirement simple , dans la première version ) c’est à dire de type "int" "double" ou "pointeur". Un argument de type "short" par exemple est converti ( suivant le compilateur ) en type "int". Un argument de type "float" est converti en "double". Bien sûr il est possible de passer en paramètre un pointeur sur un objet quelconque.
</li>
<li>
Un paramètre qui n’est pas défini est réputé de type "int".
</li>
<li>
Un tablesu est un pointeur sur le premier élément, il peut donc ètre passé comme paramètre. Lorsqu’il est passé comme paramètre seule sa première dimension peut ne pas étre précisée:
</li>

</ul>
<div class="Standard">
exp(T,U,V)
</div>
<div class="Standard">
int T[],U[][2],V[][8][10];
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
main() int I;
</div>
<div class="Standard">
Le programme C
</div>
<div class="Standard">
Un programme C est par définition un fichier C qui comprend une ou plusieurs fonctions. Pour une liaison avec le système une de ces fonctions doit porter le nom particulier "main". Chaque programme débutera par la fonction "main().
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.4.1.2">1.4.1.2</a> les fonctions d’entrée/sortie
</h4>
<div class="Standard">
Le langage C ne possède pas dans sa définition de fonctions spécifiques d’entrée/sortie. A coté d’un compilateur C il existe toujours une bibliothêque de fonctions qui peuvent être appelées comme toute fonction. Certaines de ces fonctions ont été définies pour réaliser des tâches d’entrée/sortie. Lorsque l’on utilise C sous UNIX on peut utiliser les fonctions standard d’entrée/sortie suivantes:
</div>
<div class="Standard">
read(), fread(), pour la lecture de fichier. write(), fwrite(), pour l’écriture de fichier. open(), fopen(), pour l’ouverture de fichier. creat() pour la création de fichier. close(),fclose() pour la fermeture de fichier.
</div>
<div class="Standard">
scanf(),fscanf() pour une lecture de données suivant un format. printf(),fprintf() pour l’écriture de données suivant un format.
</div>
<div class="Standard">
Bien sûr il existe un grand nombre d’autres fonctions. Ces fonctions seront examinées avec la bibliothèque standard.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-1.4.2">1.4.2</a> La notion de classes
</h3>
<div class="Standard">
Notion essentielle d’un programme C cette notion concerne les variables et les fonctions.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.4.2.1">1.4.2.1</a> Classe des variables
</h4>
<div class="Standard">
Une variable peut être dynamique ou statique, externe, locale ou définie dans un registre.
</div>
<div class="Standard">
La classe naturelle d’une variable de bloc est dynamique ou sutomatique. Les deux déclarations suivantes sont équivalentes:
</div>
<pre class="LyX-Code">
auto int I; 
int I;
</pre>
<div class="Standard">
Une variable automatique n’a d’existence que dans le bloc et lorsque celui-ci est actif. Sa valeur initiale peut être définie par une expression quelconque et est positionnée à chaque activation du bloc (certains compilateurs n’acceptent pas l’initialisation des variables automatiques ).
</div>
<pre class="LyX-Code">
int I = f(K);
</pre>
<div class="Standard">
valeur initiale de la variable I est définie par l’appel de la La fonction f().
</div>
<div class="Standard">
Une variable de type register signifie qu’elle doit utiliser autant que possible un registre. Elle peut également être initialisée de la même façon qu’une variable automatique. Seul un type simple (char, int, long) peut utiliser un type register et l’on ne peut pas utiliser l’adresse d’une telle variable:
</div>
<div class="Standard">
Si I est défini par:
</div>
<pre class="LyX-Code">
register int I;
</pre>
<div class="Standard">
alors l’instruction suivante est illégale:
</div>
<pre class="LyX-Code">
P = &amp;I;
</pre>
<div class="Standard">
Utilisation de l’adresse d’une variable de type "register".
</div>
<div class="Standard">
Une variable statique est une variable qui est toujours présente dans le programme. Son initialisation ne peut être définie que par une expression constante et cette dernière n’est réalisée qu’une seule fois su chargement du programme.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
<table>
<tr>
<td align="justify" valign="top" style="width: 60mm;">
<pre class="LyX-Code">
exp1()
{
    int I=2;
    return I++;
}
</pre>

</td>
<td align="justify" valign="top" style="width: 70mm;">
<pre class="LyX-Code">
exp2()
{
    static int I=2;
    return ++I;
}
</pre>

</td>

</tr>

</table>

</div>
<div class="Standard">
Dans la premier cas chaque appel de la fonction "expl()" initialise la variable I. Cette fonction "expl()" a donc toujours la valeur 3.
</div>
<div class="Standard">
Dans le deuxième cas la variable I n’est initialisée qu’une seule fois en début de programme et est toujours présente. Le premier appel de la fonction "exp2()" produit donc la valeur 3, mais le second appel produit la valeur 4, le troisième la valeur 5 et sinsi de suite.
</div>
<div class="Standard">
Une variable externe est une variable qui est définie en dehors des fonctions et peut par conséquent étre référencée par plusieurs fonctions.
</div>
<div class="Standard">
extern int I; autre référence à la variable I.
</div>
<div class="Standard">
Une variable externe ne peut être automatique. Elle peut par contre être statique et dans ce cas la signification est particulière. Un programme C est un fichier qui comporte plusieurs fonctions et ce programme doit étre lié à d’autres programmes pour pouvoir être exécuté. Ces autres programmes peuvent bien sfzr faire référence à des variables externes d’un fichier quelconque. Dans le cas d’une variable externe statique seules les fonctions du même fichier peuvent faire référence à cette variable. L’attribut "statique" limite donc pour une variable la portée de sa référence potentielle:
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
<table>
<tr>
<td align="justify" valign="top" style="width: 40mm;">
<div class="PlainVisible">

</div>
<div class="PlainVisible">
fichier1:<br/>
static int j;
</div>

</td>
<td align="justify" valign="top" style="width: 40mm;">
<div class="PlainVisible">

</div>
<div class="PlainVisible">
fichier2<br/>
extern int i;
</div>

</td>
<td align="justify" valign="top" style="width: 40mm;">
<div class="PlainVisible">

</div>
<div class="PlainVisible">
fichier3<br/>
int i;
</div>

</td>

</tr>

</table>

</div>
<div class="Standard">
La variable "J" ne peut étre connue que dans le fichier 1, c’est à dire par les fonctions "fl()" et "f2()". La variable I peut étre connue de toutes les fonctions "fl()", "f2()", "f3()", "f4()" et "f5()".
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1.4.2.2">1.4.2.2</a> Classe des fonctions
</h4>
<div class="Standard">
Par définition les fonctions sont de classe externe. Aussi une fonction peut être utilisée dans d’autres fichiers que celui où elle est définie sans avoir à la redéfinir.
</div>
<div class="Standard">
Lorsqu’une fonction est de classe statique cette fonction n’est connue que dans le fichier où elle est définie ( même restriction que pour les variables externes ).
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
int fl()
</div>
<div class="Standard">
static int f2()
</div>
<div class="Standard">
La fonction "fl()" peut être appelée par une fonction de n’importe quel autre fichier alors que la fonction "f2()" ne peut être appelée que par les fonctions de ce fichier, ici que par "fl()".
</div>
<div class="Standard">
 
</div>
<div class="Standard">
int modif(); I = 4;
</div>
<div class="Standard">
modif(I);
</div>
<div class="Standard">
}
</div>
<div class="Standard">
L’instruction "modif(I)" correspond à l’appel de la fonction "modif()". La variable "I" ne sera pas modifiée par cet appel. Elle sera donc toujours égale à 4.
</div>
<div class="Standard">
modif(J) int J;
</div>
<div class="Standard">
J = 3; return;
</div>
<div class="Standard">
Pour modifier la valeur de I on peut utiliser l’affectation. La procédure retourne alors la valeur souhaitée:
</div>
<div class="Standard">
main() int I;
</div>
<div class="Standard">
int modif(); I = 4;
</div>
<div class="Standard">
I = modif(I);
</div>
<div class="Standard">
modif(J) int J;
</div>
<div class="Standard">
J = 3; return J;
</div>
<div class="Standard">
Ce premier cas est celui de l’appel traditionnel par valeur. On peut simuler l’appel par nom comme dans l’exemple suivant:
</div>
<div class="Standard">
main() int I;
</div>
<div class="Standard">
int modif2(); I = 4;
</div>
<div class="Standard">
modif2(&amp;I);
</div>
<div class="Standard">
On a toujours un appel par valeur. Mais ici on passe en paramètre l’adresse de I. C’est donc une simulation d’un appel par nom. Après l’appel la variable I sera modifiée et aura la valeur 3.
</div>
<div class="Standard">
int modif2(J) int *J;
</div>
<div class="Standard">
*J = 3; return;
</div>
<div class="Standard">
La récursivité
</div>
<div class="Standard">
Contrairement à d’autres langages structurés il n’y a pas de précisions supplémentaires à donner pour définir une fonction récursive. Toute fonction C a la possibilité naturelle d’être récursive.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
La fonction suivante imprime une chaîne de caractères dans l’ordre inverse ( mot miroir ). Cette fonction est définie récursivement pour les besoins de l’exemple:
</div>
<pre class="LyX-Code">
imprr(s) 
char *s;
{
    if (!*s) return; 
    imprr(s + 1); 
    printf("%c",*s); 
    return;
}
</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> PARTAGE DE DONNEES; <br/>
PRECOMPILATION
</h1>
<div class="Standard">
Lorsque plusieurs programmes doivent traiter les mêmes données il est très u‘~ile que la définition de ces données soit unique. La modification de l’une de ces données est alors effectuée automatiquement pour tous les programmes concernés par cette donnée. Pour réaliser cet objectif il est nécessaire que la définition d’une donnée n’appartienne pas à un programme particulier. La définition de cette donnée doit donc alors être introduite automatiquement dans le programme utilisateur au moment de sa compilation. Cette opération est définie pour beaucoup de langage de programmation ( PL/1, ADA, C, ...). Cette opération s’effectue avant la compilation et ajoute donc une phase supplémentaire à la production d’un programme. 
</div>
<div class="Standard">
Cette phase est dénommée "phase de précompilation":
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.1">2.1</a> La commande include
</h2>
<div class="Standard">
Cette commande permet d’ajouter au fichier à compiler le contenu d’un autre fichier. Ainsi toutes les définitions qui doivent être utilisées par plusieurs programmes seront défiaies dans un fichier qui lui même sera introduit dans le fichier à compiler su moment de la précompilation.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
Le programme suivant réalise une liste des éléments d’un tablesu de structures. La structure est composée seulement de deux éléments : un nom et une valeur :
</div>
<pre class="LyX-Code">
main() {
    struct elem {
       char nom[8]; int val;
    } tab[10]; int i;
    for (i=0; i&lt; 10; ++i)
       scanf("%7s %d",tab[i].nom,&amp;tab[ij.val); 
    for(i = 0; i &lt; 10; ++i)
       printf("%s Xd\n",tab[i].nom,tab[i].val); 
}
</pre>
<div class="Standard">
Si dans un autre programme on utilise la même structure elle devra être redéclarée. En plaçant cette définition dans un fichier externe cette structure ne sera déclarée qu’une seule fois:
</div>
<div class="Standard">
Le fichier de définition: elem.h
</div>
<pre class="LyX-Code">
struct elem {
    char nom[8]; int val;
};
</pre>
<div class="Standard">
Le programme d’écho devient:
</div>
<pre class="LyX-Code">
#include "exemp.h" 
main()
{
    struct elem tab[10]; int i;
    for(i=0; i&lt; 10; ++i)
        scanf("X7s Xd",tab[i].nom,&amp;tab[iJ.val); 
    for(i = 0; i &lt; 10; ++i)
        printf("Xs Xd‘n",tab[iJ.nom,tab[iJ.val);
}
</pre>
<div class="Standard">
Un autre programme utilisant la même structure peut alors être défini:
</div>
<pre class="LyX-Code">
#include "elem..h"
main() {
  struct elem tab[10]; 
  int i;
  for(i=0; i&lt; 10; ++i)
    scanf("%7s %d",tab[i].nom,&amp;tab[i].val); 
  tri(tab);
  for(i = 0; i &lt; 10; ++i)
    printf("%s %d\n",tab[i].nom,tab[i].val); 
}
tri(tab) 
struct elem *tab; 
{
  int i,j,k; char c;
  j = l; 
  while (j) {
    j = 0;
    for(i=0; i &lt; 9; ++i) {
      for (k = 0; k &lt; 7; ++k)
        if (tab[i].nom[k] != tab[i+1].nom[k]) break; 

      if ((k &lt; 7) &amp;&amp; (tab[i].nom[k] &gt; tab[i+1].nom[k])) {
        j = l;
        for(k = 0; k &lt; 7; ++k) {
          c = tab[i].nom[k];
          tab[i].nom[k] = tab[i+1].nom[k]; 
          tab[i+l].nom[k] = c;
        } 
        k = tab[iJ.val;
        tab[i].val = tab[i+l].val; 
        tab[i+1].val = k;
      }
   }
 }
 return; 
}
</pre>
<div class="Standard">
La modification de la structure doit être réalisée dans le fichier de définition "elem.h". Cette modification sera alors valable pour les deux programmes.
</div>
<div class="Standard">
Lors de l’écriture d’un projet toutes les données communes à plusieurs unités de traitement de ce projet doivent être déclarées dans des fichiers externes Ces fichiers comprendront aussi les données _succentibles d’être utilisées lors des modifications ou extensions futures.
</div>
<div class="Standard">
la commande "include" distingue deux catégories de fichiers. Les fichiers systèmes qui contiennent les définitions standard liées au système et les fichiers utilisateurs spécifiques a chaque application. Les fichiers systèmes sont placés dans un endroit précis de la machine ( sous UNIX ils sont placés dans le répertoire "/usr/include". Les fichiers utilisateurs sont soit placés dans un emplacement précisé paz l’utilisateur ( sous UNIX ils sont placés dans le répertoire courant ou dans un répertoire précisé à l’appel du compilateur ). La distinction entre les deux types du fichier s’effectue par les caractères qui encadrent le nom du fichier à inclure:
</div>
<div class="Standard">
Nom de fichier entre guillemets: fichier utilisateur.
</div>
<div class="Standard">
Nom de fichier entre les symboles "&lt;" et "&gt;": fichier système. Exemple:
</div>
<div class="Standard">
#include &lt;stdio.h&gt; /* fichier système */ #include "exemp.h" /* fichier utilisateur */
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.1">2.1.1</a> La commande define
</h3>
<div class="Standard">
Au cours de la phase de précompilation le langage C permet le traitement de macro-instruction. La première fonction des macroinstructions correspond au remplacement d’une chaîne de caractères par une autre. Ce remplacement s’effectue sur toutes les occurences possibles de la chaîne source.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
La commande <tt><i>#define EXP 1</i></tt> transforme l’instruction <i>x</i> <tt><i>+= EXP * EXP</i></tt> en <tt><i>x += 1 * 1</i></tt>
</div>
<div class="Standard">
Cette possiblité permet de définir toutes les constantes machines par des noms symboliques. Ce procédé permet une plus grande aisance dans la portabilité du logiciel.
</div>
<div class="Standard">
Ce remplacement peut comprendre tout un programme:
</div>
<pre class="LyX-Code">
#define EXPI { printf("un exemple de remplacement~n"); }
</pre>
<div class="Standard">
Dans ce dernier cas la partie de programme:
</div>
<pre class="LyX-Code">
i = 0; EXP1 j = 1;
</pre>
<div class="Standard">
sera remplacée avant la compilation par la partie:
</div>
<pre class="LyX-Code">
i = 0;
printf("un exemple de remplacement~n"); } j = 1;
</pre>
<div class="Standard">
La deuxième fonction des macro-instructions concerne la définition d’une chaîne de caractères avec paramètres. Dans la chaîne de caractères résultante il y a substitution des chaînes paramètres.
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
La définition
</div>
<div class="Standard">
<tt>#define max(a,b) (a &lt; b)? b : a</tt>
</div>
<div class="Standard">
transforme la partie de programme
</div>
<div class="Standard">
<tt>x = max(z,t);</tt>
</div>
<div class="Standard">
en
</div>
<div class="Standard">
<tt>x = (z &lt; t)? t: z;</tt>
</div>
<div class="Standard">
Un nom défini dans une macro-instruction peut toujours être éliminé pour la suite de la compilation par la commande "undef". Cette commande annule la signification de la chaîne paramètre:
</div>
<div class="Standard">
Exemple:
</div>
<div class="Standard">
#define max(a,b) (a &lt; b)? b : a
</div>
<div class="Standard">
x = max(z,t); /* appel de la macro */ #undef max
</div>
<div class="Standard">
x = max(z,t); /* appel de la fonction "max" *I
</div>
<div class="Standard">
Dans le premier cas l’expression sera remplacée par l’extension de la macro-instruction. Dans le second cas aucun pré-traitement ne sera effectué et un appel à une fonction "max" sera réalisé.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.1.2">2.1.2</a> La précompilation conditionnelle
</h3>
<div class="Standard">
La précompilation conditionnelle permet de définir différents codes pour le méme programme source.
</div>
<div class="Standard">
.... ....
</div>
<div class="Standard">
l’utilisation directe du maximum par rapport à l’appel d’une fonction. La définition du maximum pourra étre alors la suivante dans le fichier MAX.h:
</div>
<pre class="LyX-Code">
#ifdef DIRECT
#define max(a,b) (a &lt; b)? b : a )
#else
max(a,b) 
int a,b;
{
   return((a &lt; b)? b : a); 
}
#endif
</pre>
<div class="Standard">
Si au debut du programme utilisant max(a,b) la constante DIRECT est définie la fonction "max" sera traitée comme une macro-instruction. Dans le cas contraire cette fonction sera définie comme une fonction standard C.
</div>
<div class="Standard">
Le programme:
</div>
<pre class="LyX-Code">
#define DIRECT 1
#include "MAX.h" 
main(){
  int x,y,z; 
  x = 0;
  y = 1;
  z = max(x,y);
}
</pre>
<div class="Standard">
sera compilé comme:
</div>
<pre class="LyX-Code">
#define max(a,b) ((a &lt; b)? b : a )
main() {
  int x,y,z;
  x = 0
  z = ((a &lt; b)? b : a );
} 
</pre>
<div class="Standard">
par contre si 
</div>
<pre class="LyX-Code">
#include "MAX.h" 
main(){
  int x,y,z; 
  x = 0;
  y = 1;
  z = max(x,y);
}
</pre>
<div class="Standard">
DIRECT n’étant pas défini
</div>
<div class="Standard">
le précompilateur fournit
</div>
<pre class="LyX-Code">
max(a,b) 
int a,b;
{
   return((a &lt; b)? b : a); 
}
main(){
  int x,y,z; 
  x = 0;
  y = 1;
  z = max(x,y);
}
</pre>
<div class="Standard">
L’instruction de précompilation conditionnelle peut également vérifier la valeur d’une expression constante. Si cette expression est non nulle alors la partie conditionnelle est prise en compte. Dans le cas contraire, c’est à dire si l’expression est nulle la partie prise en compte est la partie encadrée par les préinstructions "#else" et "#endif".
</div>
<div class="Standard">
Exemple: On souhaite placer dans une zone fixe d’une 
</div>
<div class="Standard">
longueur donnée des élements de longueur fixe. Si la longueur 
</div>
<div class="Standard">
des éléments à ranger est un sous-mutiple de la longueur de la zone 
</div>
<div class="Standard">
il faut utiliser un tableau. Dans le cas contraire il faut 
</div>
<div class="Standard">
utiliser une structure:
</div>
<pre class="LyX-Code">
#define LGZONE 512 /* longueur de la zone */
typedef struct {
  zone 
  char NOM[8];
  ïnt K; 
}ELEM; /* définition de l’élément */ 
#define LGELEM 12 /* longueur de
#if LGZONE % LGELEM 
struct ELSTR { /* tableau d’élément */ 
   ELEM TELEM[LGZONE / LGELEM]; 
   char CDR[LGZONE X LGELEM]; /* caractères de remplissage */
} PLELEM;  
#else
ELEM PLELEM[LGZONE / LGELEM]; 
#endif
</pre>

<hr class="footer"/>
<div class="footer" id="generated-by">
Document generated by <a href="http://elyxer.nongnu.org/">eLyXer 1.2.5 (2013-03-10)</a> on <span class="create-date">2014-10-11T10:32:19.432012</span>
</div>
</div>
</body>
</html>
