Le calcul sur les pointeurs

Les pointeurs sont de type "int" avec quelques nuances. Par contre on peut ajouter ou retrancher un entier à un pointeur. De même si l'on retranche deux pointeurs on obtient un entier. Ce sont les seules combinaisons permises. Lorsque l'on ajoute ou l'on retranche un entier à un pointeur l'opération s'effectue relativement à la dimension ( en octets ) de l'objet sur lequel le pointeur pointe. Cela correspond à un déplacement dans un tableau d'éléments de même type:
struct A { long K; long L;
} T[10],*P;
Chaque élément de T à 8 octets. Lorsque l'on ajoute 1 au pointeur P on lui ajoute en fait 8 :
char *C; P = T;
C = (char *) P;
Après les deux affectations suivantes les pointeurs P et C auront la même valeur:
++P; C += 8;

1.3 Les structures de contrôle

Le langage C possède une structure de blocs. Ces blocs permettent de définir un programme structuré. Plusieurs instructions permettent le traitement d'une instruction complexe ou d'un bloc. Ces instructions sont celles que l'on retouve plus ou moins dans tout langage structuré.

1.3.1 Le bloc

Un bloc est délimité par deux accolades. Il permet la définition de variables locales au bloc et elles sont déclarées dès le début de bloc. Ces variables cachent éventuellement la visibilité de variables appartenant à des blocs supérieurs. Un bloc constitue une instruction.
Exemple:
int I,J; premier bloc. Ce bloc contient deux variables locales I et J.
int I; bloc imbriqué. Ce bloc comporte une déclaration d'une variable locale I qui occulte la première variable locale I. Dans ce bloc on accède donc au deuxième I et su premier ( le seul ) J.
} ........ on accpde de nouveau au premier I ........ et bien sflr toujours à J.
.
1.3.2 La structure if-else
Cette structure classique prend la forme:
if ( expression ) instruction~l else instruction 2
L'expression est évaluée et si elle est non nulle on applique l'instruction 1. Sinon on applique l'instruction 2.
Lorsque plusieurs "if" sont imbriqués un "else" est toujours associé à l'"if" sans "else" le plus près. C'est à dire le dernier qui précède ce "else".
Exemple:
if (n > 0) if (a > b)
z = a; else z = b;
Le "else" se rapporte au "if" de la condition "a>b". Cette instruction peut définir un choix multiple :
1.3.3 La structure switch
Cette instruction permet un choix multiple. Ici une expression est évaluée et sa valeur détermine l'endroit du programme où l'on doit commencer l'exécution. Sa forme générale est la suivante:
switch ( expression) {
}
case val 1 : instruction
case val.n : instruction
default : instruction
I1 faut remarquer plusieurs conventions à propos de cette instruction "switch":
* La valeur de l'expression doit être de type "int". Toutes les valeurs associées aux différents cas sont des constantes converties en "int".
* La valeur de l'expression est comparée à chaque cas et le premier ayant la valeur de l'expression détermine le point de départ de l'exécution qui se déroule ensuite en séquence jusqu'à la fin de l'instruction "switch".
* La constante "default" permet de définir un point d'entrée quelle que soit la valeur de l'expression.
.de façons à avoir des traitements mutuellement explusifs.
1.3.4 L'instruction while
Cette instruction de boucle permet de répéter une instruction tant qu'une condition est vérifiée:
while ( expression ) instruction
Exemple:
Lecture d'un mot séparé par un blanc avec conservation des huit premiers caractères:
I = 0;
while((c = getchar()) 1= ' ') if (I < 8) NOM[I++j = c;
1.3.5 L'instruction do-while
Cette instruction est similaire à la précédente. Dans le cas de l'instruction précédente le test est d'abord effectué et par conséquent l'instruction peut ne jamais être exécutée. Dans le cas de cette instruction le test est réalisé après l'exécution de l'instruction qui est donc toujours effectuée au moins une fois.
do
instruction while( expression );
est équivalent à:
instruction 
WhilE( expression) 
  instruction
1.3.6 L'instruction for
Cette dernière instruction de boucle du langage C possède trois composantes: l'initialisation, le test et la progression. Sa forme est la suivante:
for( expression~l; expression~2; expression~3) instruction
Cette instruction est équivalente à la suite:
expression~l while(expression~2) {
instruction expression~3;
}
Chaque expression est facultative mais dans ce cas on doit laisser les points virgules. Lorsque l'expression 2 est absente elle est réputée vraie par convention ( jamais nulle ).
Exemple:
boucle infinie: for(;;) instruction
1.3.7 L'instruction break
Cette instruction arrête l'exécution d'une instruction "while", "dowhile", "for" ou "switch". Cet arrêt concerne l'instruction la plus interne lorsque plusieurs de celles-ci sont imbriquées.
Exemple:
Recherche dans une table d'un mot de huit caractères :
char T[100J[8J,NOM[8J; int I,J;
for(I = 0; I < 100; ++I) for(J = 0; J < g; ++J)
if (T[IJ[JJ 1= NOM[JJ) break; if (J == 8) break;
}
Le premier "break" arréte la comparaison des mots dès qu'il y a deux caractères différents entre le mot de la table et le mot recherché.*
Le deuxième "break" arrête la recherche dans la table dès que le mot a été trouvé. I1 a été trouvé lorsque J est égal à 8 et donc lorsque la boucle interne ne s'est pas arrétée sur le "break".
1.3.8 L'instruction continue
Cette instruction définie une nouvelle itération d'une boucle "while" .
"do-while" ou "for". Elle est équivalente à une instruction "goto" er fin de boucle. Elle est équivalente à l'instruction "goto contin;" dan: les cas suivants:
while( expression ) do for(.......) contin: ; contin: ; contin: ;
1.3.9 L'instruction goto
Le langage C possède bien évidemment une instruction de saut. Elle es rédu.ite à sa plus simple expression. Chaque instruction peut ét= identifiée par une étiquette et l'instruction "goto" fait référence l'une de ces étiquettes:
goto etiquette;
Une étiquette est un identificateur placé devant une instruction:
etiquette : instruction
1.3.10 L'instruction vide
Une instruction peut être nulle, c'est à dire vide. Elle peut servir définir un corps de boucle nul par exemple, ou à positionner ur étiquette.
Exemple:
boucle d'attente d'interruption:
for(;;) ; boucle infinie où il n'y a rien à faire.
4 Les fonctions et la notion de classes
1~1.1 Les fonctions
Une fonction C est un bloc définissant une valeur. Ce bloc possède des param8tres d'appels et un type identifiant la nature de l'élément produit.
Une fonction a la forme suivante:
type <nom de la fonction> ( <liste des paramètres> ) description des paramètres
<corps de la fonction> ?
üne fonction produit une valeur qui est définie par l'instruction "return". Si cette instruction n'est pas présente ou si elle ne définit pas de valeur la valeur de la fonction est indéfinie ( mais elle existe ).
L'instruction retum
L'instruction "return" permet de définir la valeur de la fonction. cette instruction à la forme suivante:
ou
return expression ;
return ;
La valeur de l'expression est convertie dans le type de la fonction. Dans le cas de l'expression vide la valeur transmise est indéfinie.
Exemple:
int max(a,b) int a,b;
return a>b?a:b; ?
Cette fonction retourne la valeur maximum des paramètres a et b.
les paramètres
Une particularité du langage C réside dans son mode d'appel des fonctions:
- Tout paramètre est appelé par valeur.
- Les paramètres sont en général simples ( obligatoirement simple , dans la première version ) c'est à dire de type "int" "double" ou "pointeur". Un argument de type "short" par exemple est converti ( suivant le compilateur ) en type "int". Un argument de type "float" est converti en "double". Bien s~r il est possible de passer en paramètre un pointeur sur un objet quelconque.
- Un paramètre qui n'est pas défini est réputé de type "int".
- Un tablesu est un pointeur sur le premier élément, il peut donc ètre passé comme paramètre. Lorsqu'il est passé comme paramètre seule sa première dimension peut ne pas étre précisée:
exp(T,U,V)
int T[J,U[][2],V[][8][l0~;
Exemple:
main() int I;
Le programme C
Un programme C est par définition un fichier C qui comprend une ou plusieurs fonctions. Pour une liaison avec le système une de ces ; fonctions doit porter le nom particulier "main". Chaque programme débutera par la fonction "main().
les fonctions d'entrée/sortie
Le langage C ne possède pas dans sa définition de fonctions spécifiques d'entrée/sortie. A coté d'un compilateur C il existe toujours une bibliothêque de fonctions qui peuvent être appelées comme toute fonction. Certaines de ces fonctions ont été définies pour réaliser des tâches d'entrée/sortie. Lorsque l'on utilise C sous UNIX on peut utiliser les fonctions standard d'entrée/sortie suivantes:
read(), fread(), pour la lecture de fichier. write(), fwrite(), pour l'écriture de fichier. open(), fopen(), pour l'ouverture de fichier. creat() pour la création de fichier. close(),fclose() pour la fermeture de fichier.
scanf(),fscanf() pour une lecture de données suivant un format. printf(),fprintf() pour l'écriture de données suivant un format.
Bien sQr il existe un grand nombre d'autres fonctions. Ces fonctions seront examinées avec la bibliothèque standard.
1.4.2 La notion de classes
Notion essentielle d'un programme C cette notion concerne les variables et les fonctions.
Classe des variables
Une variable peut être dynamique ou statique, externe, locale ou définie dans un registre.
La classe naturelle d'une variable de bloc est dynamique ou sutomatique. Les deux déclarations suivantes sont équivalentes:
auto int I; int I;
Une variable sutomatique n'a d'existence que dans le bloc et lorsque celui-ci est actif. Sa valeur initiale peut être définie par une ' expression quelconque et est positionnée à chaque activation du bloc ( certains compilateurs n'acceptent pas l'initialisation des variables automatiques ).
int I = f(K);
valeur initiale de la variable I est définie par l'appel de la La
fonction f().
Une variable de type register signifie qu'elle doit utiliser autant que possible un registre. Elle peut également être initialisée de la même façon qu'une variable automatique. Seul un type simple (char, int, long) peut utiliser un type register et l'on ne peut pas utiliser l'adresse d'une telle variable:
Si I est défini par:
register int I;
alors l'instruction suivante est illégale:
P = &I;
Utilisation de l'adresse d'une variable de type "register".
Une variable statique est une variable qui est toujours présente dans le programme. Son initialisation ne peut être définie que par une expression constante et cette dernière n'est réalisée qu'une seule fois su chargement du programme.
Exemple:
expl() exp2() int I = 2; static int I = 2; return ++I; return ++I;
Dans la premier cas chaque appel de la fonction "expl()" initialise la variable I. Cette fonction "expl()" a donc toujours la valeur 3.
Dans le deuxième cas la variable I n'est initialisée qu'une seule fois en début de programme et est toujours présente. Le premier appel de la fonction "exp2()" produit donc la valeur 3, mais le second appel produit la valeur 4, le troisième la valeur 5 et sinsi de suite.
Une variable externe est une variable qui est définie en dehors des fonctions et peut par conséquent étre référencée par plusieurs fonctions.
,~Y
int I; variable externe. fl()
extern int I; la variable I n'appartient pas à fl ···· mais peut être utilisée par fl.
} f2() t
extern int I; autre référence à la variable I.
Une variable externe ne peut être automatique. Elle peut par contre être statique et dans ce cas la signification est particulière. Un programme C est un fichier qui comporte plusieurs fonctions et ce programme doit étre lié à d'autres programmes pour pouvoir être exécuté. Ces autres programmes peuvent bien sfzr faire référence à des variables externes d'un fichier quelconque. Dans le cas d'une variable externe statique seules les fonctions du même fichier peuvent faire référence à cette variable. L'attribut "statique" limite donc pour une variable la portée de sa référence potentielle:
Exemple:
fichier 1 fichier 2 fichier 3
static int J; extern int I;
int I; f3() f5() fl()
···· extern int I ; extern int I,J;
f4() i
f2() extern int I;
La variable "J" ne peut étre connue que dans le fichier 1, c'est à dire par les fonctions "fl()" et "f2()". La variable I peut étre connue de toutes les fonctions "fl()", "f2()", "f3()", "f4()" et "f5()".
Classe des fonctions
Par définition les fonctions sont de classe externe. Aussi une fonction peut être utilisée dans d'autres fichiers que celui où elle est définie sans avoir à la redéfinir.
Lorsqu'une fonction est de classe statique cette fonction n'est connue que dans le fichier où elle est définie ( même restriction que pour les variables externes ).
Exemple:
int fl()
static int f2()
La fonction "fl()" peut être appelée par une fonction de n'importe quel sutre fichier alors que la fonction "f2()" ne peut être appelée que par les fonctions de ce fichier, ici que par "fl()".

int modif(); I = 4;
modif(I);
}
L'instruction "modif(I)" correspond à l'appel de la fonction "modif()". La variable "I" ne sera pas modifiée par cet appel. Elle sera donc toujours égale à 4.
modif(J) int J;
J = 3; return;
Pour modifier la valeur de I on peut utiliser l'affectation. La procédure retourne alors la valeur souhaitée:
main() int I;
int modif(); I = 4;
I = modif(I);
modif(J) int J;
J = 3; return J;
Ce premier cas est celui de l'appel traditionnel par valeur. On peut simuler l'appel par nom comme dans l'exemple suivant:
main() int I;
int modif2(); I = 4;
modif2(&I);
On a toujours un appel par valeur. Mais ici on paa5e .: paramètre l'adresse de I. C'est donc une simulation d'un appel par nom. Après l'appel la variable I sera modifiée et aura la valeur 3.
int modif2(J) int *J;
*J = 3; return;
~a récursivité
Contrairement à d'autres langages structurés il n'y a pas de précisions supplémentaires à donner pour définir une fonction récursive. Toute fonction C a la possibilité naturelle d'être récursive.
Exemple:
La fonction suivante imprime une chaîne de caractères dans l'ordre inverse ( mot miroir ). Cette fonction est définie récursivement pour les besoins de l'exemple:
imprr(s) char *s;
if (!*s) return; imprr(s + 1); printf("%c",*s); return;
