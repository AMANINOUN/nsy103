#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 2
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\bullet 0 0 1 5
\bullet 2 0 1 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Langage C
\end_layout

\begin_layout Author
Pascal Fares : ISAE Cnam Liban ©
\end_layout

\begin_layout Right Address
pfares@cofares.net
\end_layout

\begin_layout Part
Le C
\end_layout

\begin_layout Standard
Le langage C est un langage de programmation impératif et structuré permettant
 de définir des programmes pour des applications très diverses.
 Le langage C est donc un langage de programmation très général.
 En ce sens il appartient à la famille des langages dits universels comme
 Algol, Pascal, Ada, etc...
 La spécificité du langage C vient de sa définition proche d'une structure
 de machine et de son traitement des pointeurs (adresse mémoire).
 Il comprend aussi des notions de compilation conditionnelle et de traitement
 de macro-instruction qui sont essentielles dans la programmation de projet
 important.
 La structure interne de la mémoire centrale d'un ordinateur comprend des
 assemblages fixes de bits et une interprétation de ces regroupements.
 Ainsi nous avons dans la plupart des cas des octets, des mots et des mots
 longs.
 Leur interprétation peut étre caractère, entier, flottant ou pointeur (adresse).
 Ces éléments fondamentaux sont manipulés par les instructions de la machine;
 ils formeront les outils de base du langage C.
 Un programme C se réduit toujours à un ensemble de fonctions non imbriquées.
 
\end_layout

\begin_layout Chapter
Les déclarations
\end_layout

\begin_layout Section
La définition des éléments
\end_layout

\begin_layout Standard
Le langage C est un langage impératif déclaratif.
 Tout élément doit étre déclaré avant d'étre utilisé.
 Une seule exception à cette règle concerne les fonctions.
 Une fonction peut étre déclarée mais elle peut également étre définie par
 défaut.
 
\end_layout

\begin_layout Standard
Chaque nom d'un élement est composé de chiffres ou de lettres et doit commencer
 par une lettre.
 Le caractère souligné "_" est considéré comme une lettre.
 Le nombre de caractères significatifs dépend du compilateur.
 Historiquement seuls les huit premiers caractères du nom sont pris en considéra
tion; les autres caractères sont ignorés (vérifier la documentation du compilate
ur que vous utilisez).
 Un nom ne doit pas étre un mot clé; il existe 28 mots clés comme int, static,
 integer, etc....
 
\end_layout

\begin_layout Standard
Les élements de bases des variables sont au nombre de sept et correspondent
 aux différentes représentations machines (voir table 
\begin_inset CommandInset ref
LatexCommand ref
reference "TB"

\end_inset

):
\end_layout

\begin_layout Verse
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
caractère (octet)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entier court signé 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entier signé 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entier long signé 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64 bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entier non signé 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
flottant simple précision 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
flottant double précision
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64 bits
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset

Table des types et leur taille probable 
\begin_inset CommandInset label
LatexCommand label
name "TB"

\end_inset


\end_layout

\begin_layout Standard
Ces éléments représentent les variables élémentaires de la mémoire.
 Ils correspondent également à une certaine interprétation.
 La distinction sur la longueur ( nombre de bits ) d'un entier dépend de
 la machine sur laquelle le langage est implanté.
 Elle dépend également du compilateur.
 Le langage précise simplement qu'un entier long est de taille supérieure
 ou égale à un entier court.
 Pour les machines à octets un choix fréquent est celui donnée en (Tab 
\begin_inset CommandInset ref
LatexCommand vref
reference "TB"

\end_inset

):
\end_layout

\begin_layout Standard
Char et int sont des variables arithmétiques alors que "float" et "double"
 sont des variables flottantes.
 On peut définir des entiers non signés sur toutes les longueurs: 
\end_layout

\begin_layout Verse
unsigned short 
\begin_inset Newline newline
\end_inset

unsigned long.
 
\end_layout

\begin_layout Standard
Le langage ne prévoit rien sur la nature signée ou non signée du caractère
 (octet).
 Cela dépend de la machine (extension ou non du bit de signe).
\end_layout

\begin_layout Standard
Les constantes associées à ces variables sont définies de manière naturelle:
 
\end_layout

\begin_layout Itemize
un entier est une suite de chiffres précédée éventuellement d'un signe.
 
\end_layout

\begin_layout Itemize
un flottant utilise le point pour commencer la partie décimale et la lettre
 "e" ou "E" pour l'exposant: +1234.56e-7 
\end_layout

\begin_layout Itemize
un caractère est mis entre apostrophes: 'a' 
\end_layout

\begin_layout Itemize
certains caractères ne sont pas représentables.
 On utilise alors une forme spécifique pour déterminer leur code: '
\backslash
ddd' où "ddd" est le code octal du caractère.
 
\begin_inset Newline newline
\end_inset


\emph on
Exemple: '
\backslash
014' est le caractère "form feed" '
\backslash
040' est le caractère espace " "
\emph default
 
\begin_inset Newline newline
\end_inset

Certains caractères sont prédéfinis:
\begin_inset Newline newline
\end_inset


\series bold

\backslash
n
\series default
 nouvelle ligne ( line feed )
\begin_inset Newline newline
\end_inset


\series bold

\backslash
t
\series default
 tabulation 
\begin_inset Newline newline
\end_inset


\series bold

\backslash
b
\series default
 espace arière (back space) 
\begin_inset Newline newline
\end_inset


\series bold

\backslash
r
\series default
 retour chariot ( carriage return )
\begin_inset Newline newline
\end_inset


\series bold

\backslash
f
\series default
 nouvelle forme (form feed ) 
\begin_inset Newline newline
\end_inset


\series bold

\backslash

\backslash

\series default
 caractpre 
\backslash
 
\begin_inset Newline newline
\end_inset


\series bold

\backslash
'
\series default
 caractère ' 
\begin_inset Newline newline
\end_inset

Le caractère '
\series bold

\backslash
0
\series default
' représente le caractère nul (le nombre 0).
 
\end_layout

\begin_layout Itemize
Une constante entière peut étre écrite en octal ou en hexadécimal.
 Si le premier chiffre d'une constante entière est 0 alors cette constante
 est en octal ou en hexadécimal.
 Si le caractère "x" ou "X" suit le 0 alors l'entier est en hezadécimal;
 sinon il est en octal: 
\begin_inset Newline newline
\end_inset

10 
\begin_inset space ~
\end_inset

dix en base dix 
\begin_inset Newline newline
\end_inset

012 
\begin_inset space ~
\end_inset

douze en base huit soit dix en base dix 
\begin_inset Newline newline
\end_inset

OxA 
\begin_inset space ~
\end_inset

A en base seize soit dix en base dix 
\end_layout

\begin_layout Standard
Un pointeur est un entier de type indéfini (dépendant de la machine).
 On peut définir un pointeur sur n'importe quel élément.
 Le pointeur représente en fait l'adresse d'une donnée en mémoire.
\end_layout

\begin_layout Standard
Pour déclarer une variable on précise son type puis son nom.
 Si ce nom est précédé d'une étoile alors la variable est un pointeur sur
 un élément du type donné: 
\end_layout

\begin_layout Quote
int I; // I est un entier.
 
\begin_inset Newline newline
\end_inset

short int I; //I est un entier court.
 
\begin_inset Newline newline
\end_inset

int *P; //P est un pointeur sur un entier.
\end_layout

\begin_layout Standard
Une variable peut étre initialisée par une constante ou une expression constante.
 Cette constante suit la définition de la variable et est placée éventuelleroent
 entre accolades :
\end_layout

\begin_layout Quote
int k = 2; 
\begin_inset Newline newline
\end_inset

int l = { 3 }; 
\begin_inset Newline newline
\end_inset

int *p = &k; ( adresse de k ).
 
\end_layout

\begin_layout Standard
A partir de ces variables élémentaires il existe trois modes de constuction
 de variables complexes: le tableau, la structure et l'union.
 
\end_layout

\begin_layout Subsection
Le tableau 
\end_layout

\begin_layout Standard
Un tableau est un ensemble d'éléments de méme type.
 On définit un tableau par le nombre n de ces éléments et l'indice d'un
 tableau varie toujours de 0 à n-1: 
\end_layout

\begin_layout Verse
int t[10]; Tableau de 10 entiers 
\end_layout

\begin_layout Standard
Les éléments du tableau sont toujours rangés de maniére consécutive en mémoire
 et l'index d'adressage doit toujours être une valeur entière.
 Le nom du tableau est une constante pointeur et représente l'adresse du
 premier élément du tableau.
 On pourra ainsi écrire: 
\end_layout

\begin_layout Verse
int *p; 
\begin_inset Newline newline
\end_inset

p = t; affectation à P de l'adresse de t[0], qui est l'adresse du premier
 élément du tableau 
\end_layout

\begin_layout Standard
Il est bien sûr possible de définir des tableaux à plusieurs dimensions.
 Dans ce cas les bornes respectives se suivent: 
\end_layout

\begin_layout Quote
int T[10][8]; //tableau à deux dimensions.
 
\end_layout

\begin_layout Standard
Le nom du tableau est dans ce cas une constante pointeur sur un tableau:
\end_layout

\begin_layout Standard
int (*P)[8]; P = T; *P est un pointeur et pointe sur le sous-tableau T[0][].
 **P est un entier, le premier élément T[0][0].
 
\end_layout

\begin_layout Standard
Remarque: 
\end_layout

\begin_layout Standard
La définition "int **P" serait incorrecte.
 Elle signifierait pointeur sur un pointeur d'entier et serait donc équivalente
 à la déclaration "int *P[S]".
 I1 faut donc définir un pointeur sur un élément du type "T[i]".
 Cet élément est un tableau de 8 entiers.
 Les parenthèses de la définition sont donc obligatoires car les crochets
 sont prioritaires par rapport à l'étoile.
 
\end_layout

\begin_layout Standard
Les variations de l'indice dans l'ordre de rangement des éléments du tableau
 s'effectuent toujours de droite à gauche.
 
\end_layout

\begin_layout Standard
Un tableau peut étre initialisé.
 On définit l'ensemble des valeurs entre deux accolades: 
\end_layout

\begin_layout Verse
int T[10] = { 0,1,2,3,4,5,6,7,8,9 }; 
\begin_inset Newline newline
\end_inset

int S[5][2] = { 0,1 , 2,3 , 4,5 , 6,7 , 8,9 }; variation des indices de
 droite à gauche.
 
\begin_inset Newline newline
\end_inset

ou 
\begin_inset Newline newline
\end_inset

int S[5][2] = { {0,1},{2,3},{4,5},{6,7},{8,9}}; 
\end_layout

\begin_layout Paragraph
exemple:
\end_layout

\begin_layout Verse
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verbatiminput{testtab.c}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un cas particulier de tableau est celui des chaînes de caractères.
 Une chaine de caractéres est un tableau de caractères à une dimension.
 I1 existe une forme abrégée pour définir les éléments du tableau d'une
 chaine de caractères: on place la chaîne entre deux guillemets.
 Le compilateur construit alors un tableau de caractpres contenant les caractère
s de la chaine et ajoute le caractère '
\backslash
0" en fin de tableau.
 Les deux déclarations suivantes ont le même effet: 
\end_layout

\begin_layout Verse
char CH[3] = { 'u','n','
\backslash
0' }; 
\begin_inset Newline newline
\end_inset

char CH[3) = "un"; 
\end_layout

\begin_layout Description
Remarque: Le termanateur de chaîne ('
\backslash
0') est utilisé pour reconnaître la fin d'une chaîne, son absence est grâve
 des fonctions tel que 
\family typewriter
\series bold
printf
\family default
\series default
 ne saurait plus fonctionner.
\end_layout

\begin_layout Standard
Bien sûr un tableau est une constante pointeur.
 On pourra définir plus simplement la chaine comme: 
\end_layout

\begin_layout Verse
char *CH=
\begin_inset Quotes erd
\end_inset

un
\begin_inset Quotes erd
\end_inset

;
\begin_inset Newline newline
\end_inset

ou
\begin_inset Newline newline
\end_inset

char CH[] = "un";
\end_layout

\begin_layout Standard
La définition d'une table de messages pourra prendre la forme d'une table
 de pointeurs sur des chaines de caractpres : 
\end_layout

\begin_layout Verse
char *MES[3] = { "messagel","message2","message3" }; 
\end_layout

\begin_layout Standard
cette définition correspond 8 la définition: 
\end_layout

\begin_layout LyX-Code
char MES1[]="message1"; //premier tableau contenant "messagel" 
\begin_inset Newline newline
\end_inset

char MES2[] = "message2"; 
\begin_inset Newline newline
\end_inset

char MES3[] = "message3"; 
\begin_inset Newline newline
\end_inset

char *MES[3] = { MESl, MES2, MES3 }; 
\end_layout

\begin_layout LyX-Code
/** Les éléments de ce tableau sont des
\begin_inset Newline newline
\end_inset

  * pointeurs sur des caractères.
 Ils
\begin_inset Newline newline
\end_inset

  * peuvent étre initialisés avec les
\begin_inset Newline newline
\end_inset

  * constantes pointeurs MESl, MES2 et
\begin_inset Newline newline
\end_inset

  * MES3.
\begin_inset Newline newline
\end_inset

  */ 
\end_layout

\begin_layout Subsection
La structure 
\end_layout

\begin_layout Standard
La structure est un ensemble hétérogène d'éléments regroupés pour des raisons
 fonctionnelles.
 Une structure porte un nom qui identifie sa nature.
 Ce nom pourra servir à la définition de plusieurs variables de ce type.
 Une structure est introduite par le mot clé "struct" suivi du nom d'identificat
ion et enfin, entre accolades, de la description des éléments composant
 cette structure: 
\end_layout

\begin_layout LyX-Code
struct exp { 
\end_layout

\begin_layout LyX-Code
    int I; 
\begin_inset Newline newline
\end_inset

    int *P; 
\begin_inset Newline newline
\end_inset

    int TAB[10]; 
\begin_inset Newline newline
\end_inset

}; 
\begin_inset Newline newline
\end_inset

La structure "exp" est composée d'un entier, d'un pointeur sur un entier
 et d'un tableau de dix entiers.
 
\end_layout

\begin_layout Standard
La déclaration d'une structure ne définit aucune variable.
 Elle définit seulement la forme d'une structure et identifie cette forme
 par un nom.
 Dans l'exemple précédent la forme de cette structure porte le nom "exp".
 On peut alors définir des variables ayant cette forme: 
\end_layout

\begin_layout LyX-Code
struct exp A, *B, C[10]; 
\end_layout

\begin_layout LyX-Code
A est une structure de type "exp".
 
\end_layout

\begin_layout LyX-Code
B est un pointeur sur une structure de type "exp".
 
\end_layout

\begin_layout LyX-Code
C est un tableau de dix structures de type "exp".
 
\end_layout

\begin_layout Standard
L'initialisation d'une structure est similaire à l'initialisation d'un tableau.
 Les éléments sont rangés de gauche à droite ou de haut en bas:
\end_layout

\begin_layout LyX-Code
struct dex { 
\end_layout

\begin_layout LyX-Code
    int I; 
\end_layout

\begin_layout LyX-Code
    char A; 
\end_layout

\begin_layout LyX-Code
    short C[4]; 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout LyX-Code
struct dex E = { 2,'a',3,4,5,6 }; 
\end_layout

\begin_layout Standard
La déclaration d'une variable structure peut suivre directement la définition
 de type: 
\end_layout

\begin_layout LyX-Code
struct trx { 
\end_layout

\begin_layout LyX-Code
    int T[10]; 
\end_layout

\begin_layout LyX-Code
    char L[S]; 
\end_layout

\begin_layout LyX-Code
} F; /* définit une structure F de type trx.
 */
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Les structures peuvent étre imbriquées.
 
\end_layout

\begin_layout Standard
On réfère à un élément d'une structure par le nom pointé: 
\end_layout

\begin_layout LyX-Code
E.I représente l'élément I de la structure E de type dex.
 F.L[0] ou F.(L[0]) représente le premier élément du tableau L de la structure
 F de type trx.
 
\end_layout

\begin_layout Standard
Dans le cas ou il s'agit d'un pointeur sur une structure il faut utiliser
 le nom fléché "->" ( symbole "-" suivi du symbole ">" ): 
\end_layout

\begin_layout LyX-Code
B->I représente l'élément I de la structure pointée par B.
 
\end_layout

\begin_layout Standard
Ces expressions peuvent étre d'une complexité quelconque ( limites imposées
 par le compilateur ).
 
\end_layout

\begin_layout LyX-Code
struct cexp { 
\end_layout

\begin_layout LyX-Code
    struct exp K[10]; 
\end_layout

\begin_layout LyX-Code
    int A; 
\end_layout

\begin_layout LyX-Code
    struct exp *V; 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout LyX-Code
struct cexp L,*R; 
\end_layout

\begin_layout Standard
On peut alors avoir par exemple les constructions suivantes: 
\end_layout

\begin_layout LyX-Code
L.K[0].TAB[1]   deuxième élément du tableau "TAB" de la
\end_layout

\begin_layout LyX-Code
                structure premier élément du tableau K 
\end_layout

\begin_layout LyX-Code
                de la structure L.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
R->K[1].I       variable I de la structure deuxième élément du tableau K
 dans la structure pointée par R.
 
\end_layout

\begin_layout LyX-Code
*(L.V->P) valeur de la variable pointée par le pointeur P de la structure
 pointé par la variable V de la structure L
\end_layout

\begin_layout LyX-Code
R->V->P variable P de la structure pointée par la variable V de la structure
 pointée par la variable R.
 
\end_layout

\begin_layout Standard
Un cas particulier concerne les structures se référant à elles-mémes (type
 récursif): 
\end_layout

\begin_layout LyX-Code
struct cel { 
\end_layout

\begin_layout LyX-Code
    int R; 
\end_layout

\begin_layout LyX-Code
    struct cel *Suivant; 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout Standard
Ce type de structure permet de définir des listes de façon simple.
 Une cellule d'une liste du type précédent est constituée d'un entier et
 d'un pointeur sur la cellule suivante.
 
\end_layout

\begin_layout Standard
La structure suivante permet la définition d'un arbre binaire: 
\end_layout

\begin_layout LyX-Code
struct bin { 
\end_layout

\begin_layout LyX-Code
    int val; 
\end_layout

\begin_layout LyX-Code
    struct bin *gauche; 
\end_layout

\begin_layout LyX-Code
    struct bin *droite; 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout Standard
La construction de type structure sert également à définir des champs.
 Un champ est une suite continue de bits.
 Les champs doivent tous être définis à l'intérieur d'une variable élémentaire.
 Les bits de cette variable sont pris dans le même ordre mais le langage
 ne précise pas cet ordre (gauche-droite ou droite-gauche).
 Nous supposerons pour les exemples que l'on utilise l'ordre gauche-droite.
 Un champ est défini en précisant le nombre de bits qu'il contieni: 
\end_layout

\begin_layout LyX-Code
struct champ { 
\end_layout

\begin_layout LyX-Code
    unsigned prem : 4; /* les quatre premiers bits.
 */
\end_layout

\begin_layout LyX-Code
    unsigned deux : 2; /* les deux bits suivants.
   */
\end_layout

\begin_layout LyX-Code
    unsigned fin : 16; /* et les 16 derniers        */
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
Une structure de ce type fait référence à 32 bits (regroupement minimum
 existant pour contenir les trois champs ).
 Cette structure sera donc rangée dans un mot de 32 bits sur une machine
 classique.
 Dans le cas ou un int sur cette machine occupe 32 bits la structure sera
 rangée dans un "int".
 Dans le cas ou les "int" de cette machine serait aeulement de 16 bits cette
 structure serait rangée dans un tableau de deus "int": Le premier mot contiendr
ait les deux premiers champs et le deuxième mot le champ suivant.
 I1 ne doit pas y avoir de chevauchement entre les données élémentaires
 pour les champs ).
 Un champ peut ne pas Atre nommé; dans ce cas on utilise les deux poinis
 suivis de la largeur du champ anonyme.
 Ils sont utilisés pour le remplissage.
 Ainsi dans le cas précédent et en supposant qu'un int occupe 16 bits la
 structure champ est équivalente H la structure: 
\end_layout

\begin_layout LyX-Code
struct champ { 
\end_layout

\begin_layout LyX-Code
    unsigned prem: 4; 
\end_layout

\begin_layout LyX-Code
    unsigned deux: 2; 
\end_layout

\begin_layout LyX-Code
    : 10; 
\end_layout

\begin_layout LyX-Code
    unsigned fin: 16; 
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
Les champs sont des entiers.
 I1s peuvent étre utilisés comme tel.
 
\end_layout

\begin_layout Subsection
L'Union 
\end_layout

\begin_layout Standard
La mémoire est une suite de bits avec certains regroupements.
 Les regroupements peuvent étre interprétés de différentes façons.
 Ainsi un octet peut étre interprété comme un entier ou comme un caractère.
 Seul l'utilisation du regroupement détermine l'interprétation machine de
 ce regroupement.
 Les langages de programmations associent des noms à ces regroupements et
 définissent une interprétation par 1e type.
 Cette interprétation fixe associée à un regroupement peut étre quelquefois
 source de difficultés inexistantes dans la programmation assembleur.
 La définition d'union permet de définir une vision différente du méme espace
 mémoire.
 Les contraintes dues aux types sont donc ainsi levées.
 La définition d'une union suit le méme principe que celui d'une siructure
 mais chaque membre définit une interprétation du méme espace mémoire:
\end_layout

\begin_layout LyX-Code
union exp { 
\end_layout

\begin_layout LyX-Code
    int I; 
\end_layout

\begin_layout LyX-Code
    char T[2];
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Si un entier est sur 16 bits et un caractère sur 8 bits 1a définition précédente
 donnera deux interprétations de 16 bits mémoire: soit une suite de deux
 caractères, soit un entier signé.
 Les règles de traitement de l'union sont les mémes que celle de la structure.
 La zone mémoire occupée par une union est toujours la zone maximum correspondan
t à l'un de ces membres.
 
\end_layout

\begin_layout Standard
Exemple: Un registre sur le micoprocesseur 68000 possède 32 bits.
 I1 peut étre utilisé sur 16 bits et sur 8 bits.
 On peut définir toutes les interprétations d'un registre: 
\end_layout

\begin_layout LyX-Code
traitement des bits: 
\end_layout

\begin_layout LyX-Code
struct bitrg { 
\end_layout

\begin_layout LyX-Code
unsigned bit3l:l; unsigned bit30:1; unsigned bit29:1; unsigned bit28:1;
 unsigned bit27:1; unsigned bit26:1; unsigned bit25:1; unsigned bit24:1;
 unsigned bit23:1; unsigned bit22:1; unsigned bit2l:l; unsigned bit20:1;
 unsigned bitl9:l; unsigned bitl8:l; unsigned bitl7:l; unsigned bitl6:l;
 unsigned bitl5:l; unsigned bitl4:l; unsigned bitl3:l; unsigned bitl2:l;
 unsigned bitll:l; unsigned bitl0:l; unsigned bit09:1; unsigned bit08:1;
 unsigned bit07:1; unsigned bit06:1; unsigned bit05:1; unsigned bit04:1;
 unsigned bit03:1; unsigned bit02:1; unsigned bit0l:l; unsigned bit 00:1
 }; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Définition du registre: 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
union reg { 
\end_layout

\begin_layout LyX-Code
    struct bitrg H; 
\end_layout

\begin_layout LyX-Code
    char CR[4]; 
\end_layout

\begin_layout LyX-Code
    short SR[2]; 
\end_layout

\begin_layout LyX-Code
    long LR; 
\end_layout

\begin_layout LyX-Code
}; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
ainsi avec la déclaration "struct reg R"; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
R.B.bit31 représentera le bit de poids fort.
 
\end_layout

\begin_layout LyX-Code
R.CR[3] le caractère manipulé dans les instructions
\end_layout

\begin_layout LyX-Code
        machines.
 
\end_layout

\begin_layout LyX-Code
R.SR[2] le mot traité par les instructions machines.
 
\end_layout

\begin_layout LyX-Code
R.LR le mot long ou le registre en entier.
 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
La déclaration des fonctions 
\end_layout

\begin_layout Standard
I1 ne faut pas confondre la 
\emph on
définition d'une fonction
\emph default
 et sa 
\emph on
déclaration
\emph default
.
 La déclaration indique le nom de cette fonction et précise la nature du
 résultat de cette fonction.
 
\end_layout

\begin_layout Standard
Dans le langage C toutes les fonctions produisent un résultat.
 L'utilisation d'un résultat n'est pas obligatoire et une procédure peut
 étre vue comme une fonction dont on utilise pas le résultat.
 Dans le langage C la déclaration des fonctions ne donne aucune indication
 sur les paramètres ( nombre et nature ) qui doivent être passés à cette
 fonction.
 Les paramètres seront définis seulement au moment de la définition de la
 fonction.
 La cohérence entre la nature des paramètres à l'appel d'une fonction et
 celle attendue par la fonction est de la responsabilité du programmeur.
 I1 existe des programmes ( lint ) qui permettent de vérifier cette cohérence.
\end_layout

\begin_layout Standard
de même le compilateur gcc de GNU augmente C de la possibilité de signer
 les fonctions, il permet de préciser les paramètre et leurs type au moment
 de la déclaration.
 La norme initiale du langage C imposait qu'un paramètre soit de nature
 simple ( contenu dans un mot mémoire ).
 Les versions actuelles acceptent des extensions et permettent de passer
 une structure comme paramètre ( dans la norme initiale il était seulement
 possible de passer un pointeur sur une structure, ce qui reste meilleur
 car consomme mois de place dans la pile).
 La même contrainte existe sur la nature de l'objet retourné par une fonction.
 Ces restrictions initiales ne sont pas des limitations car comme il est
 possible de transmettre dans les deux sens des pointeurs sur des objets
 des objets ( le programme appelant ou appelé doit simplement comporter
 une recopie de l'objet pointé ).
 
\emph on
Ce paragraphe ne traite que de la déclaration des fonctions
\emph default
.
 Une fonction définit une valeur d'un objet quelconque.
 On définit une fonction en plaçant deux parenthèses derrière son nom.
 La fonction doit étre précédée du type d'objet qu'elle produit:
\end_layout

\begin_layout Paragraph
un exemple:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand verbatiminput
filename "testdecfonc.c"

\end_inset


\end_layout

\begin_layout LyX-Code
int f(); //fonction renvoyant un entier.
 
\end_layout

\begin_layout LyX-Code
int *f(); //fonction renvoyant un pointeur sur un entier.
 
\end_layout

\begin_layout LyX-Code
int (*f)(); pointeur sur une fonction renvoyant un entier.
\end_layout

\begin_layout LyX-Code
            La parenthèse est ici nécessaire.
 Elle précise
\end_layout

\begin_layout LyX-Code
            que l'étoile se rapporte à "f" et non à "int".
\end_layout

\begin_layout LyX-Code
            Donc au lieu d'avoir un pointeur sur "int" on a
\end_layout

\begin_layout LyX-Code
            un pointeur sur "f".
 
\end_layout

\begin_layout LyX-Code
int *(*f)(); pointeur sur une fonction renvoyant un pointeur
\end_layout

\begin_layout LyX-Code
             sur un entier.
 
\end_layout

\begin_layout LyX-Code
struct exp *f(); fonction renvoyant un pointeur sur une
\end_layout

\begin_layout LyX-Code
                 structure de type "exp".
 
\end_layout

\begin_layout Standard
Avec une fonction il est possible soit de l'appeler, soit de caluler son
 adresse.
 
\end_layout

\begin_layout Standard
Lorsqu'une fonction n'est pas déclarée elle retourne implicitement un entier.
 Lorsque l'on veut définir une procédure on définit une fonction et on n'utilise
 pas sa valeur.
 Certains compilateurs utilisent le type 
\family typewriter
\series bold
\bar under
"void"
\family default
\series default
\bar default
 pour indiquer que la valeur de la fonction ne doit pas étre utilisée.
 
\end_layout

\begin_layout Standard
Exemple de définition de fonctions: 
\end_layout

\begin_layout Verse
Soit une fonction "somme" qui retourne la somme de deux éléments.
 Les écritures suivantes ont le méme effet:
\end_layout

\begin_layout LyX-Code
x + y;      évaluation de la somme 
\end_layout

\begin_layout LyX-Code
somme(x,y); sans utilisation du résultat.
 
\end_layout

\begin_layout LyX-Code
z = x + y;      évaluation de la somme 
\end_layout

\begin_layout LyX-Code
z = somme(x,y); avec utilisation du résultat.
\end_layout

\begin_layout Standard
Lorsque l'on fait référence à une fonction comme paramètre d'une autre fonction
 on utilise implicitement son adresse: 
\end_layout

\begin_layout LyX-Code
int f(); 
\end_layout

\begin_layout LyX-Code
g(f); 
\end_layout

\begin_layout Standard
Dans g() on définit le paramètre comme un pointeur sur une fonction:
\end_layout

\begin_layout LyX-Code
g(P) 
\end_layout

\begin_layout LyX-Code
int (*p)(); 
\end_layout

\begin_layout LyX-Code
{ ....
\end_layout

\begin_layout LyX-Code
   (*p)(); appel de la fonction paramètre.
\end_layout

\begin_layout LyX-Code
   ....
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
Bien sûr les pointeurs sur des fonctions peuvent apparaitre n'importe où
 comme membre d'une structure ou élément de tableau.
 
\end_layout

\begin_layout Paragraph
Exemple:
\end_layout

\begin_layout Standard
Sur le microprocesseur 68000 il existe un tableau de vecteurs d'interruptions.
 Ce tableau définit pour chaque entrée une procédure d'exception.
 Nous pouvons le déclarer de la façon suivante: 
\end_layout

\begin_layout LyX-Code
   int (*exp)()[256]; 
\end_layout

\begin_layout LyX-Code
ou
\end_layout

\begin_layout LyX-Code
   void (*exp)()[256]; 
\end_layout

\begin_layout Subsection*
La déclaration de type : typedef 
\end_layout

\begin_layout Standard
La pseudo-fonction "typedef" permet la définition de nouveau type.
 Elle est très utile pour les programmes importants.
 Cette fonction ne définit qu'une abzéviation et n'est pas associée à la
 définition du traitement du type cozrespondant comme dans le langage ADA
 ou C++ par exemple.
 Néanmoins elle est très employée dans les programmes volumineux et permet
 de classifier les différents objets utilisés ( un nom par type d'objet
 ).
 Le mot clé "typedef" précède la déclaration:
\end_layout

\begin_layout LyX-Code
typedef int Now; Le mot "Now" devient un type nouveau
\end_layout

\begin_layout LyX-Code
                 synonyme de "int".
 
\end_layout

\begin_layout Standard
On pourra alors écrire:
\end_layout

\begin_layout LyX-Code
Now x,y; x et y sont deux entiers.
 
\end_layout

\begin_layout Standard
Bien sûr cette pseudo-fonction est valable quelle que soit la déclaration:
 
\end_layout

\begin_layout LyX-Code
typedef struct { 
\end_layout

\begin_layout LyX-Code
    char NOM[8]; 
\end_layout

\begin_layout LyX-Code
    int IX; 
\end_layout

\begin_layout LyX-Code
} TAB; 
\end_layout

\begin_layout Standard
Le mot "TAB" définit un type d'élément qui peut étre utilisé pour former
 de nouveaux objets:
\end_layout

\begin_layout LyX-Code
TAB T[100],*P: tableau de structure et pointeur sur une
\end_layout

\begin_layout LyX-Code
               structure.
\end_layout

\begin_layout LyX-Code
T[4].IX détinit l'entier IX de 1a structure en cinquième
\end_layout

\begin_layout LyX-Code
        position dans le tableau T.
 
\end_layout

\begin_layout Section
Les expressions 
\end_layout

\begin_layout Standard
Une expression définit une valeur.
 La valeur d'une expression esi très souvent une valeur élémentaire ( dans
 la norme initiale une expression définit toujours une valeur élémentaire
 ).
 Pour définir une expression on utilise des variables, des constantes et
 des opérateurs.
 Une fonction est bien sdr considérée comme un opérateur.
 Ces opérateurs permettent de calculer une nouvelle valeur à partir d'un
 ensemble d'éléments.
 
\end_layout

\begin_layout Description
Exemple: L'opérateur "&" détermine l'adresse de quelque chose.
 "&I" sera donc l'adresse de la variable I.
 
\end_layout

\begin_layout Standard
L'accès à une valeur élémentaire détermine une expression primaire.
 Une expression primaire utilise des opérateurs d'accés et est définie par:
 
\end_layout

\begin_layout Itemize
une constante.
 
\end_layout

\begin_layout Itemize
un identificateur.
 
\end_layout

\begin_layout Itemize
une chaine.
 
\end_layout

\begin_layout Itemize
une expression entre parenthèses.
\end_layout

\begin_layout Itemize
une expression primaire suivie d'une expression enire crochets.
 
\end_layout

\begin_layout Itemize
une expression primaire suivie d'une suite d'expressions entre parenthpses.
 
\end_layout

\begin_layout Itemize
une valeur primaire suivie d'un identificateur précédé d'un point.
\end_layout

\begin_layout Itemize
une expression primaire suivie d'un identificateur précédé d'une flèche.
 
\end_layout

\begin_layout Standard
Dans chaque cas la signification est différente.
 Elle correspond l'interprétation suivante: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

 constante : constante.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

 identificateur : valeur de la variable définie par cet identificateur.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

chaine : une chaine est un tableau de caractères.
 La valeur associée à une chaine est donc un pointeur sur le premier caractère
 de la chaine.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

( expression ) : valeur de l'expression.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

expression_primaire [ expression ] : accès à un tableau.
 l'expression E1[E2] à la méme signification que *((E1) + (E2))
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

expression_primaire(liste d'expression) : appel de fonction.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

 valeur_primaire.identificateur : accès à un élément de structure.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
triangleq$]
\end_layout

\end_inset

 expression_primaire->identificateur : accès à un élément d'une structure
 pointée.
 
\end_layout

\begin_layout Standard
L'évaluation d'une expression utilise toujours les mémes formes de données.
 I1 y a une conversion préalable (casting) avant toute évaluation.
 Cette conversion suit des règles simples: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

Les opérandes de type caractère et entier court sont converties en entiers.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

 Les opérandes de type flottant sont converties en double.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

 Si une opérande est de type double, les autres opérandes du mème opérateur
 sont converties en double.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

 Sinon si une opérande est de type long, les sutres opérandes sont converties
 en long.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

 Sinon si une opérande est de type unsigned, les autres opérandes sont convertie
s en unsigned.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[$
\backslash
checkmark$]
\end_layout

\end_inset

 Sinon les opérandes sont de type int.
 
\end_layout

\begin_layout Standard
Le résultat de l'expression est du type ainsi déterminé et peut étre converti
 pour une affectation par exemple.
 Les différents opérateurs accessibles dans le langage C sont les suivants:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="52" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="block" valignment="top" width="40mm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Les opération arithmétique
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mois ou opposé
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2 ou 3 - 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5+8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiplier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5*8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
division
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5/2 
\begin_inset Formula $\triangleq$
\end_inset

 (2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reste ou modulo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5%2
\begin_inset Formula $\triangleq$
\end_inset

  1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateurs booléens
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
bit à bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compléments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~0
\begin_inset Formula $\triangleq$
\end_inset

 255
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
union
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0f|0xf0 
\begin_inset Formula $\triangleq$
\end_inset

0xff
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
union exlusive
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xff^0xff
\backslash
triangleq
\begin_inset space ~
\end_inset

0x00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
intersection
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x0f&0xf0
\backslash
triangleq0x00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateurs de décalage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
décalage droit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111000>>2
\begin_inset Formula $\triangleq$
\end_inset

001110
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
décalage gauche
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateurs logiques
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
non
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
différent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3!=2 
\begin_inset Formula $\triangleq$
\end_inset

vrai
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inférieur
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inférieur ou égal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
supérieur
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
supérieur ou égal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
et
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ou
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateur d'affectation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
changement de l'état mémoir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
affectation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ajout afectation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x+=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
soustraire
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x-=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

-1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiplier
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x*=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
diviser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x/=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reste
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x%=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
decaler droite
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

32,x>>=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
decaler gauche
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x<<=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
et binaire
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x&=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ou binaire
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x|=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xor binaire
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,x+=2
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateur d'incrémentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++exp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pré-incrémentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,y = ++x
\begin_inset Formula $\rightarrow$
\end_inset

x=2,y=2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exp++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
post-incrémentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\begin_inset Formula $\triangleq$
\end_inset

1,y = x++
\begin_inset Formula $\rightarrow$
\end_inset

x
\begin_inset Formula $\triangleq$
\end_inset

2,y
\begin_inset Formula $\triangleq$
\end_inset

1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--exp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pré-décrémentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exp--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
post-incrémentation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateur calcul d'adresse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adresse de
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y
\begin_inset Formula $\triangleq$
\end_inset

1,x=&y
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateur d'accés
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
valeur dont l'adresse est
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*x
\begin_inset Formula $\triangleq$
\end_inset

1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opérateur de taille
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sizeof
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sizeof(int)
\begin_inset Formula $\triangleq$
\end_inset

2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opérateur de type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casting
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(type)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Opérateur eval en séquence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y=(x=1,x=x+2)
\begin_inset Formula $\rightarrow$
\end_inset

y
\begin_inset Formula $\triangleq$
\end_inset

3,x
\begin_inset Formula $\triangleq$
\end_inset

3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
opérateur conditionel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e0 ? e1 : e2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(2>1?'a':'b')
\begin_inset Formula $\triangleq$
\end_inset

'a'
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Les booléens en C
\end_layout

\begin_layout Standard
Il n'y a pas de booléen au sens propre du terme en C, par contre toute valeur
 numérique nulle est considérée fausse et toute valeur non nulle est considérée
 vraie
\end_layout

\begin_layout Description
Exemple
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand verbatiminput
filename "bool.c"

\end_inset


\end_layout

\begin_layout Section
Le calcul sur les pointeurs
\end_layout

\begin_layout Standard
Les pointeurs sont de type "int" avec quelques nuances.
 Par contre on peut ajouter ou retrancher un entier à un pointeur.
 De même si l'on retranche deux pointeurs on obtient un entier.
 Ce sont les seules combinaisons permises.
 Lorsque l'on ajoute ou l'on retranche un entier à un pointeur l'opération
 s'effectue relativement à la dimension ( en octets ) de l'objet sur lequel
 le pointeur pointe.
 Cela correspond à un déplacement dans un tableau d'éléments de même type:
\end_layout

\begin_layout LyX-Code
struct A 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
    long K; 
\end_layout

\begin_layout LyX-Code
    long L;
\end_layout

\begin_layout LyX-Code
} T[10],*P;
\end_layout

\begin_layout Standard
Chaque élément de T à 8 octets.
 Lorsque l'on ajoute 1 au pointeur P on lui ajoute en fait 8 :
\end_layout

\begin_layout LyX-Code
char *C; P = T;
\end_layout

\begin_layout LyX-Code
C = (char *) P;
\end_layout

\begin_layout Standard
Après les deux affectations suivantes les pointeurs P et C auront la même
 valeur:
\end_layout

\begin_layout LyX-Code
++P; C += 8;
\end_layout

\begin_layout Section
Les structures de contrôle
\end_layout

\begin_layout Standard
Le langage C possède une structure de blocs.
 Ces blocs permettent de définir un programme structuré.
 Plusieurs instructions permettent le traitement d'une instruction complexe
 ou d'un bloc.
 Ces instructions sont celles que l'on retouve plus ou moins dans tout langage
 structuré.
\end_layout

\begin_layout Subsection
Le bloc
\end_layout

\begin_layout Standard
Un bloc est délimité par deux accolades.
 Il permet la définition de variables locales au bloc et elles sont déclarées
 dès le début de bloc.
 Ces variables cachent éventuellement la visibilité de variables appartenant
 à des blocs supérieurs.
 Un bloc constitue une instruction.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    int I,J; /* premier bloc.
 
\end_layout

\begin_layout LyX-Code
              * Ce bloc contient deux variables 
\end_layout

\begin_layout LyX-Code
              * locales I et J.
\end_layout

\begin_layout LyX-Code
              */
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
        int I; /* bloc imbriqué.
 
\end_layout

\begin_layout LyX-Code
                * Ce bloc comporte une déclaration d'une
\end_layout

\begin_layout LyX-Code
                * variable locale I qui occulte la première
\end_layout

\begin_layout LyX-Code
                * variable locale I.
 
\end_layout

\begin_layout LyX-Code
                * Dans ce bloc on accède 
\end_layout

\begin_layout LyX-Code
                * donc au deuxième I et sur J bien sûr
\end_layout

\begin_layout LyX-Code
                *
\end_layout

\begin_layout LyX-Code
    } 
\end_layout

\begin_layout LyX-Code
    ........
\end_layout

\begin_layout LyX-Code
    /* on accède de nouveau au premier I 
\end_layout

\begin_layout LyX-Code
     */
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
La structure if-else
\end_layout

\begin_layout Standard
Cette structure classique prend la forme:
\end_layout

\begin_layout LyX-Code
if ( expression ) <instructionV>else <instructionF>
\end_layout

\begin_layout Standard
L'expression est évaluée et si elle est non nulle on applique l'instructionV.
 Sinon on applique l'instructionF.
\end_layout

\begin_layout Standard
Lorsque plusieurs "if" sont imbriqués un "else" est toujours associé à l'"if"
 sans "else" le plus près.
 C'est à dire le dernier qui précède ce "else".
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
if (n > 0) if (a > b)
\end_layout

\begin_layout Standard
z = a; else z = b;
\end_layout

\begin_layout Standard
Le "else" se rapporte au "if" de la condition "a>b".
 Cette instruction peut définir un choix multiple :
\end_layout

\begin_layout Subsection
La structure switch
\end_layout

\begin_layout Standard
Cette instruction permet un choix multiple.
 Ici une expression est évaluée et sa valeur détermine l'endroit du programme
 où l'on doit commencer l'exécution.
 Sa forme générale est la suivante:
\end_layout

\begin_layout LyX-Code
switch ( expression) {
\end_layout

\begin_layout LyX-Code
    case val_1 : instruction
\end_layout

\begin_layout LyX-Code
    case val_n : instruction
\end_layout

\begin_layout LyX-Code
    default : instruction
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
I1 faut remarquer plusieurs conventions à propos de cette instruction "switch":
\end_layout

\begin_layout Itemize
La valeur de l'expression doit être de type "int".
 Toutes les valeurs associées aux différents cas sont des constantes converties
 en "int".
\end_layout

\begin_layout Itemize
La valeur de l'expression est comparée à chaque cas et le premier ayant
 la valeur de l'expression détermine le point de départ de l'exécution qui
 se déroule ensuite en séquence jusqu'à la fin de l'instruction "switch".
\end_layout

\begin_layout Itemize
La constante "default" permet de définir un point d'entrée quelle que soit
 la valeur de l'expression de façons à avoir des traitements mutuellement
 explusifs.
\end_layout

\begin_layout Subsection
L'instruction while
\end_layout

\begin_layout Standard
Cette instruction de boucle permet de répéter une instruction tant qu'une
 condition est vérifiée:
\end_layout

\begin_layout LyX-Code
while ( expression ) instruction
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
Lecture d'un mot séparé par un blanc avec conservation des huit premiers
 caractères:
\end_layout

\begin_layout LyX-Code
int i = 0;
\end_layout

\begin_layout LyX-Code
while((c = getchar()) != ' ') if (I < 8) NOM[i++] = c;
\end_layout

\begin_layout Subsection
L'instruction do-while
\end_layout

\begin_layout Standard
Cette instruction est similaire à la précédente.
 Dans le cas de l'instruction précédente le test est d'abord effectué et
 par conséquent l'instruction peut ne jamais être exécutée.
 Dans le cas de cette instruction le test est réalisé après l'exécution
 de l'instruction qui est donc toujours effectuée au moins une fois.
\end_layout

\begin_layout LyX-Code
do <instruction> while( expression );
\end_layout

\begin_layout Standard
est équivalent à:
\end_layout

\begin_layout LyX-Code
instruction 
\end_layout

\begin_layout LyX-Code
WhilE( expression) instruction
\end_layout

\begin_layout Subsection
L'instruction for
\end_layout

\begin_layout Standard
Cette dernière instruction de boucle du langage C possède trois composantes:
 l'initialisation, le test et la progression.
 Sa forme est la suivante:
\end_layout

\begin_layout LyX-Code
for( expression~l; expression~2; expression~3) instruction
\end_layout

\begin_layout Standard
Cette instruction est équivalente à la suite:
\end_layout

\begin_layout LyX-Code
expression~l while(expression~2) {
\end_layout

\begin_layout LyX-Code
    instruction 
\end_layout

\begin_layout LyX-Code
    expression~3;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Chaque expression est facultative mais dans ce cas on doit laisser les points
 virgules.
 Lorsque l'expression 2 est absente elle est réputée vraie par convention
 ( jamais nulle ).
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout LyX-Code
boucle infinie: for(;;) instruction
\end_layout

\begin_layout Subsection
L'instruction break
\end_layout

\begin_layout Standard
Cette instruction arrête l'exécution d'une instruction "while", "dowhile",
 "for" ou "switch".
 Cet arrêt concerne l'instruction la plus interne lorsque plusieurs de celles-ci
 sont imbriquées.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
Recherche dans une table d'un mot de huit caractères :
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
char T[100][8],NOM[8]; 
\end_layout

\begin_layout LyX-Code
int I,J;
\end_layout

\begin_layout LyX-Code
for(I = 0; I < 100; ++I) 
\end_layout

\begin_layout LyX-Code
    for(J = 0; J < 8; ++J)
\end_layout

\begin_layout LyX-Code
        if (T[I][J] != NOM[J]) break; 
\end_layout

\begin_layout LyX-Code
        if (J == 8) break;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Le premier "break" arréte la comparaison des mots dès qu'il y a deux caractères
 différents entre le mot de la table et le mot recherché.
\end_layout

\begin_layout Standard
Le deuxième "break" arrête la recherche dans la table dès que le mot a été
 trouvé.
 I1 a été trouvé lorsque J est égal à 8 et donc lorsque la boucle interne
 ne s'est pas arrétée sur le "break".
\end_layout

\begin_layout Subsection
L'instruction continue
\end_layout

\begin_layout Standard
Cette instruction définie une nouvelle itération d'une boucle "while" .
\end_layout

\begin_layout Standard
"do-while" ou "for".
 Elle est équivalente à une instruction "goto" ver la fin de boucle.
 Elle est équivalente à l'instruction "goto contin;" dans les cas suivants:
\end_layout

\begin_layout Standard
while( expression ) do for(.......) contin: ; contin: ; contin: ;
\end_layout

\begin_layout Subsection
L'instruction goto
\end_layout

\begin_layout Standard
Le langage C possède bien évidemment une instruction de saut.
 Elle es rédu.ite à sa plus simple expression.
 Chaque instruction peut ét= identifiée par une étiquette et l'instruction
 "goto" fait référence l'une de ces étiquettes:
\end_layout

\begin_layout Standard
goto etiquette;
\end_layout

\begin_layout Standard
Une étiquette est un identificateur placé devant une instruction:
\end_layout

\begin_layout Standard
etiquette : instruction
\end_layout

\begin_layout Subsection
L'instruction vide
\end_layout

\begin_layout Standard
Une instruction peut être nulle, c'est à dire vide.
 Elle peut servir définir un corps de boucle nul par exemple, ou à positionner
 une étiquette.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
boucle d'attente d'interruption:
\end_layout

\begin_layout LyX-Code
for(;;) ;
\end_layout

\begin_layout Standard
boucle infinie où il n'y a rien à faire.
\end_layout

\begin_layout Section
Les fonctions et la notion de classes
\end_layout

\begin_layout Subsection
Les fonctions
\end_layout

\begin_layout Standard
Une fonction C est un bloc définissant une valeur.
 Ce bloc possède des paramétres d'appels et un type identifiant la nature
 de l'élément produit.
\end_layout

\begin_layout Standard
Une fonction a la forme suivante:
\end_layout

\begin_layout LyX-Code
type <nom de la fonction> ( <liste des paramètres> ) 
\end_layout

\begin_layout LyX-Code
description des paramètres
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    <corps de la fonction>
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
üne fonction produit une valeur qui est définie par l'instruction "return".
 Si cette instruction n'est pas présente ou si elle ne définit pas de valeur
 la valeur de la fonction est indéfinie ( mais elle existe ).
\end_layout

\begin_layout Subsubsection
L'instruction retum
\end_layout

\begin_layout Standard
L'instruction "return" permet de définir la valeur de la fonction.
 cette instruction à la forme suivante:
\end_layout

\begin_layout LyX-Code
   return expression ;
\end_layout

\begin_layout LyX-Code
ou
\end_layout

\begin_layout LyX-Code
   return ;
\end_layout

\begin_layout Standard
La valeur de l'expression est convertie dans le type de la fonction.
 Dans le cas de l'expression vide la valeur transmise est indéfinie.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout LyX-Code
int max(a,b) 
\end_layout

\begin_layout LyX-Code
int a,b;
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    return a>b?a:b; 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Cette fonction retourne la valeur maximum des paramètres a et b.
\end_layout

\begin_layout Standard
les paramètres
\end_layout

\begin_layout Standard
Une particularité du langage C réside dans son mode d'appel des fonctions:
\end_layout

\begin_layout Itemize
Tout paramètre est appelé par valeur.
\end_layout

\begin_layout Itemize
Les paramètres sont en général simples ( obligatoirement simple , dans la
 première version ) c'est à dire de type "int" "double" ou "pointeur".
 Un argument de type "short" par exemple est converti ( suivant le compilateur
 ) en type "int".
 Un argument de type "float" est converti en "double".
 Bien sûr il est possible de passer en paramètre un pointeur sur un objet
 quelconque.
\end_layout

\begin_layout Itemize
Un paramètre qui n'est pas défini est réputé de type "int".
\end_layout

\begin_layout Itemize
Un tablesu est un pointeur sur le premier élément, il peut donc ètre passé
 comme paramètre.
 Lorsqu'il est passé comme paramètre seule sa première dimension peut ne
 pas étre précisée:
\end_layout

\begin_layout Standard
exp(T,U,V)
\end_layout

\begin_layout Standard
int T[],U[][2],V[][8][10];
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
main() int I;
\end_layout

\begin_layout Standard
Le programme C
\end_layout

\begin_layout Standard
Un programme C est par définition un fichier C qui comprend une ou plusieurs
 fonctions.
 Pour une liaison avec le système une de ces fonctions doit porter le nom
 particulier "main".
 Chaque programme débutera par la fonction "main().
\end_layout

\begin_layout Subsubsection
les fonctions d'entrée/sortie
\end_layout

\begin_layout Standard
Le langage C ne possède pas dans sa définition de fonctions spécifiques
 d'entrée/sortie.
 A coté d'un compilateur C il existe toujours une bibliothêque de fonctions
 qui peuvent être appelées comme toute fonction.
 Certaines de ces fonctions ont été définies pour réaliser des tâches d'entrée/s
ortie.
 Lorsque l'on utilise C sous UNIX on peut utiliser les fonctions standard
 d'entrée/sortie suivantes:
\end_layout

\begin_layout Standard
read(), fread(), pour la lecture de fichier.
 write(), fwrite(), pour l'écriture de fichier.
 open(), fopen(), pour l'ouverture de fichier.
 creat() pour la création de fichier.
 close(),fclose() pour la fermeture de fichier.
\end_layout

\begin_layout Standard
scanf(),fscanf() pour une lecture de données suivant un format.
 printf(),fprintf() pour l'écriture de données suivant un format.
\end_layout

\begin_layout Standard
Bien sûr il existe un grand nombre d'autres fonctions.
 Ces fonctions seront examinées avec la bibliothèque standard.
\end_layout

\begin_layout Subsection
La notion de classes
\end_layout

\begin_layout Standard
Notion essentielle d'un programme C cette notion concerne les variables
 et les fonctions.
\end_layout

\begin_layout Subsubsection
Classe des variables
\end_layout

\begin_layout Standard
Une variable peut être dynamique ou statique, externe, locale ou définie
 dans un registre.
\end_layout

\begin_layout Standard
La classe naturelle d'une variable de bloc est dynamique ou sutomatique.
 Les deux déclarations suivantes sont équivalentes:
\end_layout

\begin_layout LyX-Code
auto int I; 
\end_layout

\begin_layout LyX-Code
int I;
\end_layout

\begin_layout Standard
Une variable automatique n'a d'existence que dans le bloc et lorsque celui-ci
 est actif.
 Sa valeur initiale peut être définie par une expression quelconque et est
 positionnée à chaque activation du bloc (certains compilateurs n'acceptent
 pas l'initialisation des variables automatiques ).
\end_layout

\begin_layout LyX-Code
int I = f(K);
\end_layout

\begin_layout Standard
valeur initiale de la variable I est définie par l'appel de la La fonction
 f().
\end_layout

\begin_layout Standard
Une variable de type register signifie qu'elle doit utiliser autant que
 possible un registre.
 Elle peut également être initialisée de la même façon qu'une variable automatiq
ue.
 Seul un type simple (char, int, long) peut utiliser un type register et
 l'on ne peut pas utiliser l'adresse d'une telle variable:
\end_layout

\begin_layout Standard
Si I est défini par:
\end_layout

\begin_layout LyX-Code
register int I;
\end_layout

\begin_layout Standard
alors l'instruction suivante est illégale:
\end_layout

\begin_layout LyX-Code
P = &I;
\end_layout

\begin_layout Standard
Utilisation de l'adresse d'une variable de type "register".
\end_layout

\begin_layout Standard
Une variable statique est une variable qui est toujours présente dans le
 programme.
 Son initialisation ne peut être définie que par une expression constante
 et cette dernière n'est réalisée qu'une seule fois su chargement du programme.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="block" valignment="top" width="60mm">
<column alignment="block" valignment="top" width="70mm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="minipage">
\begin_inset Text

\begin_layout LyX-Code
exp1()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    int I=2;
\end_layout

\begin_layout LyX-Code
    return I++;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout LyX-Code
exp2()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    static int I=2;
\end_layout

\begin_layout LyX-Code
    return ++I;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Dans la premier cas chaque appel de la fonction "expl()" initialise la variable
 I.
 Cette fonction "expl()" a donc toujours la valeur 3.
\end_layout

\begin_layout Standard
Dans le deuxième cas la variable I n'est initialisée qu'une seule fois en
 début de programme et est toujours présente.
 Le premier appel de la fonction "exp2()" produit donc la valeur 3, mais
 le second appel produit la valeur 4, le troisième la valeur 5 et sinsi
 de suite.
\end_layout

\begin_layout Standard
Une variable externe est une variable qui est définie en dehors des fonctions
 et peut par conséquent étre référencée par plusieurs fonctions.
\end_layout

\begin_layout Standard
extern int I; autre référence à la variable I.
\end_layout

\begin_layout Standard
Une variable externe ne peut être automatique.
 Elle peut par contre être statique et dans ce cas la signification est
 particulière.
 Un programme C est un fichier qui comporte plusieurs fonctions et ce programme
 doit étre lié à d'autres programmes pour pouvoir être exécuté.
 Ces autres programmes peuvent bien sfzr faire référence à des variables
 externes d'un fichier quelconque.
 Dans le cas d'une variable externe statique seules les fonctions du même
 fichier peuvent faire référence à cette variable.
 L'attribut "statique" limite donc pour une variable la portée de sa référence
 potentielle:
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="3">
<features tabularvalignment="middle">
<column alignment="block" valignment="top" width="40mm">
<column alignment="block" valignment="top" width="40mm">
<column alignment="block" valignment="top" width="40mm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fichier1:
\end_layout

\begin_layout Plain Layout
static int j;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fichier2
\end_layout

\begin_layout Plain Layout
extern int i;
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fichier3
\end_layout

\begin_layout Plain Layout
int i;
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
La variable "J" ne peut étre connue que dans le fichier 1, c'est à dire
 par les fonctions "fl()" et "f2()".
 La variable I peut étre connue de toutes les fonctions "fl()", "f2()",
 "f3()", "f4()" et "f5()".
\end_layout

\begin_layout Subsubsection
Classe des fonctions
\end_layout

\begin_layout Standard
Par définition les fonctions sont de classe externe.
 Aussi une fonction peut être utilisée dans d'autres fichiers que celui
 où elle est définie sans avoir à la redéfinir.
\end_layout

\begin_layout Standard
Lorsqu'une fonction est de classe statique cette fonction n'est connue que
 dans le fichier où elle est définie ( même restriction que pour les variables
 externes ).
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
int fl()
\end_layout

\begin_layout Standard
static int f2()
\end_layout

\begin_layout Standard
La fonction "fl()" peut être appelée par une fonction de n'importe quel
 autre fichier alors que la fonction "f2()" ne peut être appelée que par
 les fonctions de ce fichier, ici que par "fl()".
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
int modif(); I = 4;
\end_layout

\begin_layout Standard
modif(I);
\end_layout

\begin_layout Standard
}
\end_layout

\begin_layout Standard
L'instruction "modif(I)" correspond à l'appel de la fonction "modif()".
 La variable "I" ne sera pas modifiée par cet appel.
 Elle sera donc toujours égale à 4.
\end_layout

\begin_layout Standard
modif(J) int J;
\end_layout

\begin_layout Standard
J = 3; return;
\end_layout

\begin_layout Standard
Pour modifier la valeur de I on peut utiliser l'affectation.
 La procédure retourne alors la valeur souhaitée:
\end_layout

\begin_layout Standard
main() int I;
\end_layout

\begin_layout Standard
int modif(); I = 4;
\end_layout

\begin_layout Standard
I = modif(I);
\end_layout

\begin_layout Standard
modif(J) int J;
\end_layout

\begin_layout Standard
J = 3; return J;
\end_layout

\begin_layout Standard
Ce premier cas est celui de l'appel traditionnel par valeur.
 On peut simuler l'appel par nom comme dans l'exemple suivant:
\end_layout

\begin_layout Standard
main() int I;
\end_layout

\begin_layout Standard
int modif2(); I = 4;
\end_layout

\begin_layout Standard
modif2(&I);
\end_layout

\begin_layout Standard
On a toujours un appel par valeur.
 Mais ici on passe en paramètre l'adresse de I.
 C'est donc une simulation d'un appel par nom.
 Après l'appel la variable I sera modifiée et aura la valeur 3.
\end_layout

\begin_layout Standard
int modif2(J) int *J;
\end_layout

\begin_layout Standard
*J = 3; return;
\end_layout

\begin_layout Standard
La récursivité
\end_layout

\begin_layout Standard
Contrairement à d'autres langages structurés il n'y a pas de précisions
 supplémentaires à donner pour définir une fonction récursive.
 Toute fonction C a la possibilité naturelle d'être récursive.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
La fonction suivante imprime une chaîne de caractères dans l'ordre inverse
 ( mot miroir ).
 Cette fonction est définie récursivement pour les besoins de l'exemple:
\end_layout

\begin_layout LyX-Code
imprr(s) 
\end_layout

\begin_layout LyX-Code
char *s;
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    if (!*s) return; 
\end_layout

\begin_layout LyX-Code
    imprr(s + 1); 
\end_layout

\begin_layout LyX-Code
    printf("%c",*s); 
\end_layout

\begin_layout LyX-Code
    return;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Chapter
PARTAGE DE DONNEES; 
\begin_inset Newline newline
\end_inset

PRECOMPILATION
\end_layout

\begin_layout Standard
Lorsque plusieurs programmes doivent traiter les mêmes données il est très
 u`~ile que la définition de ces données soit unique.
 La modification de l'une de ces données est alors effectuée automatiquement
 pour tous les programmes concernés par cette donnée.
 Pour réaliser cet objectif il est nécessaire que la définition d'une donnée
 n'appartienne pas à un programme particulier.
 La définition de cette donnée doit donc alors être introduite automatiquement
 dans le programme utilisateur au moment de sa compilation.
 Cette opération est définie pour beaucoup de langage de programmation (
 PL/1, ADA, C, ...).
 Cette opération s'effectue avant la compilation et ajoute donc une phase
 supplémentaire à la production d'un programme.
 
\end_layout

\begin_layout Standard
Cette phase est dénommée "phase de précompilation":
\end_layout

\begin_layout Section
La commande include
\end_layout

\begin_layout Standard
Cette commande permet d'ajouter au fichier à compiler le contenu d'un autre
 fichier.
 Ainsi toutes les définitions qui doivent être utilisées par plusieurs programme
s seront défiaies dans un fichier qui lui même sera introduit dans le fichier
 à compiler su moment de la précompilation.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
Le programme suivant réalise une liste des éléments d'un tablesu de structures.
 La structure est composée seulement de deux éléments : un nom et une valeur
 :
\end_layout

\begin_layout LyX-Code
main() {
\end_layout

\begin_layout LyX-Code
    struct elem {
\end_layout

\begin_layout LyX-Code
       char nom[8]; int val;
\end_layout

\begin_layout LyX-Code
    } tab[10]; int i;
\end_layout

\begin_layout LyX-Code
    for (i=0; i< 10; ++i)
\end_layout

\begin_layout LyX-Code
       scanf("%7s %d",tab[i].nom,&tab[ij.val); 
\end_layout

\begin_layout LyX-Code
    for(i = 0; i < 10; ++i)
\end_layout

\begin_layout LyX-Code
       printf("%s Xd
\backslash
n",tab[i].nom,tab[i].val); 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Si dans un autre programme on utilise la même structure elle devra être
 redéclarée.
 En plaçant cette définition dans un fichier externe cette structure ne
 sera déclarée qu'une seule fois:
\end_layout

\begin_layout Standard
Le fichier de définition: elem.h
\end_layout

\begin_layout LyX-Code
struct elem {
\end_layout

\begin_layout LyX-Code
    char nom[8]; int val;
\end_layout

\begin_layout LyX-Code
};
\end_layout

\begin_layout Standard
Le programme d'écho devient:
\end_layout

\begin_layout LyX-Code
#include "exemp.h" 
\end_layout

\begin_layout LyX-Code
main()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
    struct elem tab[10]; int i;
\end_layout

\begin_layout LyX-Code
    for(i=0; i< 10; ++i)
\end_layout

\begin_layout LyX-Code
        scanf("X7s Xd",tab[i].nom,&tab[iJ.val); 
\end_layout

\begin_layout LyX-Code
    for(i = 0; i < 10; ++i)
\end_layout

\begin_layout LyX-Code
        printf("Xs Xd`n",tab[iJ.nom,tab[iJ.val);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Un autre programme utilisant la même structure peut alors être défini:
\end_layout

\begin_layout LyX-Code
#include "elem..h"
\end_layout

\begin_layout LyX-Code
main() {
\end_layout

\begin_layout LyX-Code
  struct elem tab[10]; 
\end_layout

\begin_layout LyX-Code
  int i;
\end_layout

\begin_layout LyX-Code
  for(i=0; i< 10; ++i)
\end_layout

\begin_layout LyX-Code
    scanf("%7s %d",tab[i].nom,&tab[i].val); 
\end_layout

\begin_layout LyX-Code
  tri(tab);
\end_layout

\begin_layout LyX-Code
  for(i = 0; i < 10; ++i)
\end_layout

\begin_layout LyX-Code
    printf("%s %d
\backslash
n",tab[i].nom,tab[i].val); 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
tri(tab) 
\end_layout

\begin_layout LyX-Code
struct elem *tab; 
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  int i,j,k; char c;
\end_layout

\begin_layout LyX-Code
  j = l; 
\end_layout

\begin_layout LyX-Code
  while (j) {
\end_layout

\begin_layout LyX-Code
    j = 0;
\end_layout

\begin_layout LyX-Code
    for(i=0; i < 9; ++i) {
\end_layout

\begin_layout LyX-Code
      for (k = 0; k < 7; ++k)
\end_layout

\begin_layout LyX-Code
        if (tab[i].nom[k] != tab[i+1].nom[k]) break; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
      if ((k < 7) && (tab[i].nom[k] > tab[i+1].nom[k])) {
\end_layout

\begin_layout LyX-Code
        j = l;
\end_layout

\begin_layout LyX-Code
        for(k = 0; k < 7; ++k) {
\end_layout

\begin_layout LyX-Code
          c = tab[i].nom[k];
\end_layout

\begin_layout LyX-Code
          tab[i].nom[k] = tab[i+1].nom[k]; 
\end_layout

\begin_layout LyX-Code
          tab[i+l].nom[k] = c;
\end_layout

\begin_layout LyX-Code
        } 
\end_layout

\begin_layout LyX-Code
        k = tab[iJ.val;
\end_layout

\begin_layout LyX-Code
        tab[i].val = tab[i+l].val; 
\end_layout

\begin_layout LyX-Code
        tab[i+1].val = k;
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
 }
\end_layout

\begin_layout LyX-Code
 return; 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
La modification de la structure doit être réalisée dans le fichier de définition
 "elem.h".
 Cette modification sera alors valable pour les deux programmes.
\end_layout

\begin_layout Standard
Lors de l'écriture d'un projet toutes les données communes à plusieurs unités
 de traitement de ce projet doivent être déclarées dans des fichiers externes
 Ces fichiers comprendront aussi les données _succentibles d'être utilisées
 lors des modifications ou extensions futures.
\end_layout

\begin_layout Standard
la commande "include" distingue deux catégories de fichiers.
 Les fichiers systèmes qui contiennent les définitions standard liées au
 système et les fichiers utilisateurs spécifiques a chaque application.
 Les fichiers systèmes sont placés dans un endroit précis de la machine
 ( sous UNIX ils sont placés dans le répertoire "/usr/include".
 Les fichiers utilisateurs sont soit placés dans un emplacement précisé
 paz l'utilisateur ( sous UNIX ils sont placés dans le répertoire courant
 ou dans un répertoire précisé à l'appel du compilateur ).
 La distinction entre les deux types du fichier s'effectue par les caractères
 qui encadrent le nom du fichier à inclure:
\end_layout

\begin_layout Standard
Nom de fichier entre guillemets: fichier utilisateur.
\end_layout

\begin_layout Standard
Nom de fichier entre les symboles "<" et ">": fichier système.
 Exemple:
\end_layout

\begin_layout Standard
#include <stdio.h> /* fichier système */ #include "exemp.h" /* fichier utilisateur
 */
\end_layout

\begin_layout Subsection
La commande define
\end_layout

\begin_layout Standard
Au cours de la phase de précompilation le langage C permet le traitement
 de macro-instruction.
 La première fonction des macroinstructions correspond au remplacement d'une
 chaîne de caractères par une autre.
 Ce remplacement s'effectue sur toutes les occurences possibles de la chaîne
 source.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
La commande 
\family typewriter
\emph on
#define EXP 1
\family default
\emph default
 transforme l'instruction 
\emph on
x
\emph default
 
\family typewriter
\emph on
+= EXP * EXP
\family default
\emph default
 en 
\family typewriter
\emph on
x += 1 * 1
\end_layout

\begin_layout Standard
Cette possiblité permet de définir toutes les constantes machines par des
 noms symboliques.
 Ce procédé permet une plus grande aisance dans la portabilité du logiciel.
\end_layout

\begin_layout Standard
Ce remplacement peut comprendre tout un programme:
\end_layout

\begin_layout LyX-Code
#define EXPI { printf("un exemple de remplacement~n"); }
\end_layout

\begin_layout Standard
Dans ce dernier cas la partie de programme:
\end_layout

\begin_layout LyX-Code
i = 0; EXP1 j = 1;
\end_layout

\begin_layout Standard
sera remplacée avant la compilation par la partie:
\end_layout

\begin_layout LyX-Code
i = 0;
\end_layout

\begin_layout LyX-Code
printf("un exemple de remplacement~n"); } j = 1;
\end_layout

\begin_layout Standard
La deuxième fonction des macro-instructions concerne la définition d'une
 chaîne de caractères avec paramètres.
 Dans la chaîne de caractères résultante il y a substitution des chaînes
 paramètres.
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
La définition
\end_layout

\begin_layout Standard

\family typewriter
#define max(a,b) (a < b)? b : a
\end_layout

\begin_layout Standard
transforme la partie de programme
\end_layout

\begin_layout Standard

\family typewriter
x = max(z,t);
\end_layout

\begin_layout Standard
en
\end_layout

\begin_layout Standard

\family typewriter
x = (z < t)? t: z;
\end_layout

\begin_layout Standard
Un nom défini dans une macro-instruction peut toujours être éliminé pour
 la suite de la compilation par la commande "undef".
 Cette commande annule la signification de la chaîne paramètre:
\end_layout

\begin_layout Standard
Exemple:
\end_layout

\begin_layout Standard
#define max(a,b) (a < b)? b : a
\end_layout

\begin_layout Standard
x = max(z,t); /* appel de la macro */ #undef max
\end_layout

\begin_layout Standard
x = max(z,t); /* appel de la fonction "max" *I
\end_layout

\begin_layout Standard
Dans le premier cas l'expression sera remplacée par l'extension de la macro-inst
ruction.
 Dans le second cas aucun pré-traitement ne sera effectué et un appel à
 une fonction "max" sera réalisé.
\end_layout

\begin_layout Subsection
La précompilation conditionnelle
\end_layout

\begin_layout Standard
La précompilation conditionnelle permet de définir différents codes pour
 le méme programme source.
\end_layout

\begin_layout Standard
....
 ....
\end_layout

\begin_layout Standard
l'utilisation directe du maximum par rapport à l'appel d'une fonction.
 La définition du maximum pourra étre alors la suivante dans le fichier
 MAX.h:
\end_layout

\begin_layout LyX-Code
#ifdef DIRECT
\end_layout

\begin_layout LyX-Code
#define max(a,b) (a < b)? b : a )
\end_layout

\begin_layout LyX-Code
#else
\end_layout

\begin_layout LyX-Code
max(a,b) 
\end_layout

\begin_layout LyX-Code
int a,b;
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   return((a < b)? b : a); 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\begin_layout Standard
Si au debut du programme utilisant max(a,b) la constante DIRECT est définie
 la fonction "max" sera traitée comme une macro-instruction.
 Dans le cas contraire cette fonction sera définie comme une fonction standard
 C.
\end_layout

\begin_layout Standard
Le programme:
\end_layout

\begin_layout LyX-Code
#define DIRECT 1
\end_layout

\begin_layout LyX-Code
#include "MAX.h" 
\end_layout

\begin_layout LyX-Code
main(){
\end_layout

\begin_layout LyX-Code
  int x,y,z; 
\end_layout

\begin_layout LyX-Code
  x = 0;
\end_layout

\begin_layout LyX-Code
  y = 1;
\end_layout

\begin_layout LyX-Code
  z = max(x,y);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
sera compilé comme:
\end_layout

\begin_layout LyX-Code
#define max(a,b) ((a < b)? b : a )
\end_layout

\begin_layout LyX-Code
main() {
\end_layout

\begin_layout LyX-Code
  int x,y,z;
\end_layout

\begin_layout LyX-Code
  x = 0
\end_layout

\begin_layout LyX-Code
  z = ((a < b)? b : a );
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
par contre si 
\end_layout

\begin_layout LyX-Code
#include "MAX.h" 
\end_layout

\begin_layout LyX-Code
main(){
\end_layout

\begin_layout LyX-Code
  int x,y,z; 
\end_layout

\begin_layout LyX-Code
  x = 0;
\end_layout

\begin_layout LyX-Code
  y = 1;
\end_layout

\begin_layout LyX-Code
  z = max(x,y);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
DIRECT n'étant pas défini
\end_layout

\begin_layout Standard
le précompilateur fournit
\end_layout

\begin_layout LyX-Code
max(a,b) 
\end_layout

\begin_layout LyX-Code
int a,b;
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   return((a < b)? b : a); 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
main(){
\end_layout

\begin_layout LyX-Code
  int x,y,z; 
\end_layout

\begin_layout LyX-Code
  x = 0;
\end_layout

\begin_layout LyX-Code
  y = 1;
\end_layout

\begin_layout LyX-Code
  z = max(x,y);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
L'instruction de précompilation conditionnelle peut également vérifier la
 valeur d'une expression constante.
 Si cette expression est non nulle alors la partie conditionnelle est prise
 en compte.
 Dans le cas contraire, c'est à dire si l'expression est nulle la partie
 prise en compte est la partie encadrée par les préinstructions "#else"
 et "#endif".
\end_layout

\begin_layout Standard
Exemple: On souhaite placer dans une zone fixe d'une 
\end_layout

\begin_layout Standard
longueur donnée des élements de longueur fixe.
 Si la longueur 
\end_layout

\begin_layout Standard
des éléments à ranger est un sous-mutiple de la longueur de la zone 
\end_layout

\begin_layout Standard
il faut utiliser un tableau.
 Dans le cas contraire il faut 
\end_layout

\begin_layout Standard
utiliser une structure:
\end_layout

\begin_layout LyX-Code
#define LGZONE 512 /* longueur de la zone */
\end_layout

\begin_layout LyX-Code
typedef struct {
\end_layout

\begin_layout LyX-Code
  zone 
\end_layout

\begin_layout LyX-Code
  char NOM[8];
\end_layout

\begin_layout LyX-Code
  ïnt K; 
\end_layout

\begin_layout LyX-Code
}ELEM; /* définition de l'élément */ 
\end_layout

\begin_layout LyX-Code
#define LGELEM 12 /* longueur de
\end_layout

\begin_layout LyX-Code
#if LGZONE % LGELEM 
\end_layout

\begin_layout LyX-Code
struct ELSTR { /* tableau d'élément */ 
\end_layout

\begin_layout LyX-Code
   ELEM TELEM[LGZONE / LGELEM]; 
\end_layout

\begin_layout LyX-Code
   char CDR[LGZONE X LGELEM]; /* caractères de remplissage */
\end_layout

\begin_layout LyX-Code
} PLELEM;  
\end_layout

\begin_layout LyX-Code
#else
\end_layout

\begin_layout LyX-Code
ELEM PLELEM[LGZONE / LGELEM]; 
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\end_body
\end_document
