\documentclass[letterpaper]{article}
\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse % we do not use PDFLaTeX
\else
  \pdfoutput=1 % we use PDFLaTeX
  \pdftrue
\fi
\usepackage{linuxdoc-sgml}
\usepackage{qwertz}
\usepackage{url}
\usepackage[latin1]{inputenc}
\ifpdf
  \usepackage[pdftex,colorlinks=true,urlcolor=blue,linkcolor=blue]{hyperref}
  \pdfcompresslevel=9
\else
  \usepackage{t1enc}
%%  \usepackage[dvips]{hyperref}
\fi
\usepackage[english]{babel}
\usepackage{epsfig}
\usepackage{null}
\def\addbibtoc{
\addcontentsline{toc}{section}{\numberline{\mbox{}}\relax\bibname}
}%end-preamble
\setcounter{page}{1}
\urldef{\aaaurl} \url{http://cvs.vim.org/cgi-bin/cvsweb/vim/runtime/doc}
\urldef{\aaburl} \url{http://www.vim.org}
\urldef{\aacurl} \url{http://www.us.vim.org}
\urldef{\aadurl} \url{ftp://ftp.vim.org/pub/vim}
\urldef{\aaeurl} \url{ftp://ftp.vim.org/pub/vim/MIRRORS}
\urldef{\aafurl} \url{http://www.winzip.com}
\urldef{\aagurl} \url{http://www.polarfox.com/vim}
\urldef{\aahurl} \url{http://www.rational.com}
\urldef{\aaiurl} \url{http://www.insure.com}
\urldef{\aajurl} \url{http://www.vim.org}
\urldef{\aakurl} \url{http://www.us.vim.org}
\urldef{\aalurl} \url{http://www.grafnetix.com/~laurent/vim/faq.html}
\urldef{\aamurl} \url{http://www.vim.org/faq}
\urldef{\aanurl} \url{http://www.netusa.net/~eli/src/vim.html}
\urldef{\aaourl} \url{http://www.cs.vu.nl/~tmgil/vi.html}
\urldef{\aapurl} \url{http://scisun.sci.ccny.cuny.edu/~olrcc/vim/}
\urldef{\aaqurl} \url{http://www.findmail.com/listsaver/vimannounce.html}
\urldef{\aarurl} \url{http://www.vim.org/mail.html}
\urldef{\aasurl} \url{http://www.egroups.com/group/vim}
\urldef{\aaturl} \url{http://www.egroups.com/group/vimdev}
\urldef{\aauurl} \url{http://www.egroups.com/group/vimannounce}
\urldef{\aavurl} \url{http://www.grafnetix.com/~laurent/vim/macros.html}
\urldef{\aawurl} \url{http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/}
\urldef{\aaxurl} \url{http://linuxwww.db.erau.edu/LUG/node165.html}
\urldef{\aayurl} \url{http://www.yggdrasil.com/bible/bible-src/user-alpha-4/guide/node171.html}
\urldef{\aazurl} \url{http://www.cfm.brown.edu/Unixhelp/vi_.html}
\urldef{\abaurl} \url{http://www.linuxbox.com/~taylor/4ltrwrd/section3_4.html}
\urldef{\abburl} \url{http://www.networkcomputing.com/unixworld/unixhome.html}
\urldef{\abcurl} \url{http://www.eng.hawaii.edu/Tutor/vi.html}
\urldef{\abdurl} \url{http://www.infobound.com/vi.html}
\urldef{\abeurl} \url{http://www.tc.cornell.edu/Edu/Tutor/Basics/vi/}
\urldef{\abfurl} \url{http://www.cs.vu.nl/~tmgil/vi.html}
\urldef{\abgurl} \url{http://www.thomer.com/thomer/vi/vi.html}
\urldef{\abhurl} \url{http://www.cs.umr.edu/unixinfo/general/packages/viguide.html}
\urldef{\abiurl} \url{http://www.vmunix.com/~gabor/vi.html}
\urldef{\abjurl} \url{http://www.math.fu-berlin.de/~guckes/vim/faq/}
\urldef{\abkurl} \url{http://www.metalab.unc.edu/LDP/HOWTO/C-C++Beautifier-HOWTO.html}
\urldef{\ablurl} \url{http://www.aldev.8m.com}
\urldef{\abmurl} \url{http://www.aldev.webjump.com}
\urldef{\abnurl} \url{ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/}
\urldef{\abourl} \url{ftp://metalab.unc.edu/pub/Linux/docs/HOWTO}
\urldef{\abpurl} \url{ftp://metalab.unc.edu/pub/Linux/docs/HOWTO}
\urldef{\abqurl} \url{http://www.sgmltools.org}
\urldef{\abrurl} \url{http://www.adobe.com}
\urldef{\absurl} \url{http://metalab.unc.edu/LDP/HOWTO/ViM-HOWTO.html}
\urldef{\abturl} \url{http://www.caldera.com/LDP/HOWTO/ViM-HOWTO.html}
\urldef{\abuurl} \url{http://www.WGS.com/LDP/HOWTO/ViM-HOWTO.html}
\urldef{\abvurl} \url{http://www.cc.gatech.edu/linux/LDP/HOWTO/ViM-HOWTO.html}
\urldef{\abwurl} \url{http://www.redhat.com/linux-info/ldp/HOWTO/ViM-HOWTO.html}
\urldef{\abxurl} \url{http://metalab.unc.edu/LDP/mirrors.html}
\urldef{\abyurl} \url{http://www.cs.wisc.edu/~ghost}
\title{HOWTO de l'éditeur ViM couleur (Vi aMélioré, avec coloration syntaxique)}
\author{Al Dev (Alavoor Vasudevan) 
\ifpdf
\href{mailto:alavoor@yahoo.com}{alavoor@yahoo.com}
\else
\onlynameurl{alavoor@yahoo.com}
\fi
;\\ 
Version française par Arnaud Launay,
{\ttfamily 
\ifpdf
\href{mailto:asl@launay.org}{asl@launay.org}
\else
\onlynameurl{asl@launay.org}
\fi
}}
\date{v14.0, 16 Août 2000}
\abstract{Ce document est un guide pour configurer très rapidement l'éditeur couleur ViM
sur les systèmes Linux ou Unix. Les informations présentées ici augmenteront la
productivité du programmeur puisque l'éditeur ViM supporte la coloration
syntaxique et les fontes grasses qui augmentent la « lisibilité » du code. La
productivité d'un programmeur est accrue de 2 à 3 fois avec un éditeur couleur
comme ViM.
Les informations de ce document s'appliquent à tous les systèmes d'exploitation
sous lesquels Vim fonctionne, c'est-à-dire Windows 95/NT, Apple Mac, et toutes
les versions d'Unix telles que Linux, FreeBSD, Solaris, HPUX, AIX, SCO, Ultrix,
Sinix, BSD, SCO, etc. (ce qui revient à dire, à peu près tous les OS de la
planète !).}


\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

L'éditeur ViM signifie « Vi iMproved » (Vi amélioré). Vi est l'éditeur le plus
populaire et le plus puissant du monde Unix. Son nom vient de l'abbréviation
éditeur {\itshape {\bfseries Vi}\/}suel. Un éditeur visuel comme Vi était un grand
progrès par rapport aux éditeurs en ligne comme 'ed' (ou 'ex'). Les éditeurs
'ed' et 'ex' sont toujours disponibles sous Linux : voyez 'man ed' et 'man ex'.

Un bon éditeur augmentera la productivité du programmeur. Vim supporte la
coloration syntaxique du code ainsi que différentes fontes, normales,
grasses ou italiques. Les éditeurs couleurs comme ViM augmentent la productivité du
programmeur de 2 à 3 fois ! Les programmeurs peuvent lire le code beaucoup plus
rapidement si la syntaxe du code est colorées et mise en évidence.




\subsection{Avant d'installer \label{avant}}

Avant d'installer ViM, référez vous aux notes relevant de l'OS et aux
informations sur la compilation et l'usage de ViM sur -
\begin{itemize}
\item  Allez ici et regardez les fichiers os\_*.txt 
{\em } {\tt \aaaurl}
\end{itemize}


Si vous n'avez pas le paquetage ViM (RPM, DEB, tar, zip) alors chargez le code
source par ftp sur le site officiel de ViM
\begin{itemize}
\item La page maison de ViM est sur 
{\em } {\tt \aaburl}
\item Le site miroir US est sur 
{\em } {\tt \aacurl}
\item Le site FTP est sur 
{\em } {\tt \aadurl}
\item Ou utilisez un des miroirs sur 
{\em } {\tt \aaeurl}
\end{itemize}





\subsection{Installer ViM sous RedHat Linux}

Pour utiliser ViM, installez les paquetages rpm suivants sous RedHat -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        rpm -i vim*.rpm
Ou comme ceci -
        rpm -i vim-enhanced*.rpm
        rpm -i vim-X11*.rpm
        rpm -i vim-common*.rpm
        rpm -i vim-minimal*.rpm
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Vous pouvez voir la liste des fichiers ViM que rpm a installé par
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        rpm -qa | grep ^vim | xargs rpm -ql | less
ou
        rpm -qa | grep ^vim | awk '{print "rpm -ql " $1 }' | /bin/sh | less
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Et regardez la sortie en utilisant j, k, CTRL+f, CTRL+D, CTRL+B, CTRL+U ou les
touches fléchées, page up/down. Voyez aussi 'man less'.



Notez que les paquetages RPM pour RedHat Linux utilisent une interface Motif.
Si vous avez installé les librairies GTK sur votre système, vous pouvez
envisager de recompiler ViM à partir du source code afin de bénéficier d'une
interface graphique propre. Pour les informations sur la compilation du code de
ViM, voyez « installer ViM sur Unix » plus bas.




\subsection{Installer ViM sous GNU Debian Linux}

Pour installer ViM sous Debian Linux (GNU Linux), identifiez vous en tant que superutilisateur et lorsque vous êtes connecté à Internet tapez -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
apt-get install vim vim-rt
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Cela chargera la dernière version de ViM, l'installera, le configurera, et
supprimera les fichiers .deb chargés. Le premier paquetage listé est
ViM, l'éditeur standard, compilé avec support pour X11, vim-rt est le
vim-runtime, c'est-à-dire les fichiers de syntaxe et d'aide.




\subsection{Installer ViM sous Unix}

Pour les autres versions d'Unix comme Solaris, HPUX, AIX, Sinix, SCO,
récupérez les fichiers sources (voyez \ref{avant} {()})
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        zcat vim.tar.gz | tar -xvf -
        cd vim-5.6/src
        ./configure --enable-gui=motif
        make
        make install
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Installer ViM sous Microsoft Windows 95/NT}

Pour Windows 95/NT, récupérez les fichiers zip et installez-les en cliquant
sur setup. Vous devez charger DEUX fichiers zip -
\begin{itemize}
\item  Fichier contenant le runtime {\bfseries vim*rt.zip}
\item  Fichier de commande ViM {\bfseries vim*56.zip} dont la version est la 5.6
\end{itemize}


Récupérez ces deux fichiers (voir \ref{avant} {()})

Décompactez les fichiers zip en utilisant Winzip 
{\em } {\tt \aafurl}
. Les deux fichiers zip (vim*rt.zip et
vim*56.zip) doivent être décompressés dans le même répertoire, disons
{\bfseries c:$\backslash$vim}.

Pour Windows 95/98, ajoutez la variable d'environnement VIM dans autoexec.bat
en ajoutant cette ligne -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
set VIM=c:\vim\vim56
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pour Windows NT, ajoutez la variable d'environnement dans le dialogue
{\bfseries Control Panel $|$ System $|$ Environment $|$ System Properties} :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
VIM=c:\vim\vim56
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


La variable VIM doit pointer là où vous avez installé le répertoire vim56.
Vous pouvez aussi ajouter l'emplacement de gvim.exe à votre PATH.

Il est probable que vous deviez vous déconnecter et vous réidentifier pour
avoir les bonnes variables. À l'invite MSDOS tapez -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        set vim
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Et vous devriez voir - VIM=c:$\backslash$vim$\backslash$vim56

Créez un raccourci sur votre bureau en copiant/collant de
c:$\backslash$vim$\backslash$vim56$\backslash$gvim.exe. Copiez le fichier gvimrc\_example vers \$VIM$\backslash$\_gvimrc.
Dans mon cas, il s'agit de c:$\backslash$vim$\backslash$vim56$\backslash$\_gvimrc.




\subsection{Installer ViM sous VMS}




\subsubsection{Charger les fichiers}

Vous aurez besoin des archives Unix et extra pour construire vim.exe pour VMS.
Pour utiliser toute la puissance de ViM vous aurez également besoin des
fichiers runtime. Prenez ces fichiers (voir \ref{avant} {()}).

Vous pouvez charger des exécutables précompilés sur 
{\em } {\tt \aagurl}
.

Les auteurs de ViM VMS sont -
\begin{itemize}
\item 
\ifpdf
\href{mailto: zoltan.arpadffy@essnet.se    }{ zoltan.arpadffy@essnet.se  }
\else
\onlynameurl{ zoltan.arpadffy@essnet.se  }
\fi
\item 
\ifpdf
\href{mailto: arpadffy@altavista.net    }{ arpadffy@altavista.net  }
\else
\onlynameurl{ arpadffy@altavista.net  }
\fi
\item 
\ifpdf
\href{mailto:  cec@gryphon.gsfc.nasa.gov    }{  cec@gryphon.gsfc.nasa.gov  }
\else
\onlynameurl{  cec@gryphon.gsfc.nasa.gov  }
\fi
\item 
\ifpdf
\href{mailto: BNHunsaker@chq.byu.edu    }{ BNHunsaker@chq.byu.edu  }
\else
\onlynameurl{ BNHunsaker@chq.byu.edu  }
\fi
\item 
\ifpdf
\href{mailto: sandor.kopanyi@altavista.net    }{ sandor.kopanyi@altavista.net  }
\else
\onlynameurl{ sandor.kopanyi@altavista.net  }
\fi
\end{itemize}





\subsubsection{Compiler}

Décompactez les archives Unix et Extra dans un même répertoire. Dans le
sous-répertoire {$<$}.SRC{$>$} vous devriez trouver le fichier make OS\_VMS.MMS. En
éditant ce fichier vous pourrez choisir les versions des caractères, des
interfaces et du débogage. Il y a également des options additionnelles
concernant les supports pour Perl, Python et Tcl.

Vous aurez besoin soit de l'utilitaire DECSET mms ou du clone disponible
gratuitement appellé mmk (VMS n'a pas d'utilitaire make en distribution
standard). Vous pouvez récupérer mmk sur http://www.openvms.digital.com/freeware/MMK/

Si vous avez MMS sur votre système, la commande

{$>$}   mms /descrip=os\_vms.mms

construira votre version personnalisée de ViM.
La commande équivalente pour mmk est :

{$>$}   mmk /descrip=os\_vms.mms




\subsubsection{Déploiement}

ViM utilise une structure de répertoires spéciale pour les fichiers de
documentation et d'utilisation :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
   vim (ou autre)
    |- tmp
    |- vim55
    |----- doc
    |----- syntax
    |- vim56
    |----- doc
    |----- syntax
    vimrc    (fichiers système rc)
    gvimrc
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Utilisez :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       define/nolog device:[leading-path-here.vim]       vim
>       define/nolog device:[leading-path-here.vim.vim56] vimruntime
>       define/nolog device:[leading-path-here.tmp]       tmp
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

pour que vim.exe puisse trouver ses fichiers de documents, ses types de
fichiers et de syntaxe, et pour spécifier un répertoire où les fichiers
temporaires seront placés. Copiez le sous-répertoire « runtime » de la
distribution vim dans vimruntime.

Note : les variables \$VIMRUNTIME et \$TMP sont optionnelles. Lisez en plus sur
:help runtime.




\subsubsection{Usage pratique}

Habituellement vous devrez faire tourner une seule version de ViM sur votre
système, il est donc suffisant de dédier un seul répertoire à ViM.
Copiez toute la structure des répertoires de runtime dans la position de
déploiement. Ajoutez les lignes suivantes à votre LOGIN.COM (dans le
répertoire SYS\$LOGIN). Définissez la variable \$VIM en tant que :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       $ define VIM device: <path>
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Configurez quelques symboles :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       $ ! vi lance ViM en mode caractère
>       $ vi*m  :== mcr device:<path>VIM.EXE

>       $ !gvi lance ViM en mode GUI
>       $ gv*im :== spawn/nowait mcr device:<path>VIM.EXE -g
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Créez les fichiers .vimrc et .gvimrc dans votre répertoire personnel
(SYS\$LOGIN).

La méthode la plus simple est de renommer les fichiers d'exemples. Vous pouvez
laisser le fichier de menu (MENU.VIM) et les fichiers vimrc et gvimrc dans le
répertoire original \$VIM. Ce sera la configuration par défaut pour tous les
utilisateurs, mais ceux-ci pourront apporter leurs propres modifications à la
configuration via les fichiers .vimrc et .gvimrc de leur répertoire personnel.
Ceci devrait marcher sans problème.

Note : Rappellez-vous, les fichiers systèmes rc (défaut pour tous les
utilisateurs) n'ont pas de~«~.~»~final. Ainsi, les fichiers systèmes rc sont :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       VIM$:vimrc
>       VIM$:gvimrc
>       VIM$:menu.vim
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

et les fichiers utilisateurs personnalisés sont :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       sys$login:.vimrc
>       sys$login:.gvimrc
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Vous pouvez vérifier que tout fonctionne et est à la bonne place avec la
commande~:version.

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Exemple de LOGIN.COM :

>       $ define/nolog VIM RF10:[UTIL.VIM]
>       $ vi*m  :== mcr VIM:VIM.EXE
>       $ gv*im :== spawn/nowait mcr VIM:VIM.EXE -g
>       $ set disp/create/node=192.168.5.223/trans=tcpip
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Note : Cette configuration devrait être suffisante si vous travaillez sur un
serveur seul ou dans un environnement clusterisé, mais si vous désirez
utiliser ViM en tant qu'éditeur internoeuds, il suffit de définir le
«~chemin~» complet :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       $ define VIM "<server_name>[""user password""]::device:<path>"
>       $ vi*m :== "mcr VIM:VIM.EXE"
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


par exemple :

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
>       $ define VIM "PLUTO::RF10:[UTIL.VIM]"
>       $ define VIM "PLUTO""ZAY mypass""::RF10:[UTIL.VIM]" ! si un pass est nécessaire
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Vous pouvez aussi utiliser la variable \$VIMRUNTIME pour pointer sur la bonne
version de ViM si vous avez plusieurs versions installées en même temps. Si
\$VIMRUNTIME n'est pas défini ViM prendra la valeur de la variable \$VIM. Vous
pourrez trouver plus d'informations sur la variable \$VIMRUNTIME en tapant
:help runtime en commande ViM.




\subsubsection{Questions sur le mode GUI}

VMS n'est pas un environnement X window natif, vous ne pouvez donc pas lancer
ViM en mode GUI « juste comme ça ». Mais ce n'est pas trop compliqué d'obtenir
un ViM fonctionnel.

\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
1) Si vous travaillez sur la console X VMS.
   Lancez ViM avec la commande :

>       $ mc device:<path>VIM.EXE -g

ou tapez :gui en commande à l'invite ViM. Pour plus d'infos tapez :help gui

2) Si vous travaillez sur un autre environnement X window comme Unix ou une
console VMS X distante. Configurez votre affichage sur cet hôte avec :

>       $ set disp/create/node=<addresse IP>/trans=<nom-transport>

et lancez ViM comme au point 1. Vous pourrez trouver plus d'aide dans la
documentation VMS ou tapez: help set disp à l'invite VMS.
   Exemples :

>       $ set disp/create/node=192.168.5.159             ! transport par défaut DECNet
>       $ set disp/create/node=192.168.5.159/trans=tcpip ! réseau TCP/IP
>       $ set disp/create/node=192.168.5.159/trans=local ! affichage sur le même noeud
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Note : Vous ne devez en définir qu'un. Pour plus d'infos tapez \$help set disp à
l'invite VMS.




\subsection{Installer ViM sous OS/2}

Lisez les notes de version de ViM sur OS/2, voyez \ref{avant} {()}.

Pour le moment il n'y a pas de version PM native de la version GUI de ViM ; la
version OS/2 est une application en console. Néanmoins, il y a maintenant une
version Win32s-compatible GUI, qui devrait être utilisable par les
utilisateurs de Warp4 (qui supporte Win32s) dans une session Win-OS/2. Les
notes de ce fichier se réfèrent à la version console native.

Pour utiliser ViM, vous aurez besoin de l'environnement de lancement emx (au
moins la version 0.9b). Elle est généralement disponible en tant que (demandez le à
Archie) :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
    emxrt.zip     emx runtime package
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Installer ViM sur Apple Macintosh}

Lisez les notes de version de ViM sur Mac, voyez \ref{avant} {()}.

L'auteur de ViM sur Mac (de l'ancienne version 3.0) est
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
Eric Fischer
5759 N. Guilford Ave
Indianapolis IN 46220 USA
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Écrivez à
\ifpdf
\href{mailto: enf@pobox.com   }{ enf@pobox.com  }
\else
\onlynameurl{ enf@pobox.com  }
\fi


Rapport de Bogue Mac.
Lorsque vous avez à rapporter tout changement spécifique au Mac, bogue ou
option, incluez l'adresse suivante dans le champ « To: » ou « Copy To: ».
\ifpdf
\href{mailto:  dany.stamant@sympatico.ca          }{  dany.stamant@sympatico.ca  }
\else
\onlynameurl{  dany.stamant@sympatico.ca  }
\fi


ViM compile sans ajout avec le projet CodeWarrior en utilisant CodeWarrior 9.
Si vous utilisez une version plus récente (CW Pro) vous devrez convertir le
projet avant toute chose.
Pour compiler ViM pour Macs 68k vous devrez ouvrir la ressource « size » dans
ResEdit et activer le bouton « High level events aware » pour avoir un
copier/coller fonctionnel.
Vous devrez augmenter la partition de mémoire à au moins 1024 koctets pour
éviter à ViM de se crasher faute de mémoire suffisante.




\section{Configurez les fichiers d'initialisation de ViM}

Pour permettre la coloration syntaxique, vous DEVEZ copier le fichier vimrc
dans votre répertoire personnel. Il ajoutera également le menu « Syntax » pour
la commande gvim. Vous pouvez cliquer sur le menu Syntax et sélectionner le
langage approprié, comme C++, Perl, Java, SQL, ESQL, etc.
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
cd $HOME
cp /usr/doc/vim-common-5.7/gvimrc_example  ~/.gvimrc
cp /usr/doc/vim-common-5.7/vimrc_example  ~/.vimrc
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Les commentaires du .vimrc commencent avec les apostrophes (").
Vous pouvez personnaliser vim en éditant le fichier \$HOME/.vimrc et en
rajoutant les lignes suivantes :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
set guifont=8x13bold
"set guifont=9x15bold
"set guifont=7x14bold
"set guifont=7x13bold
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Il est {\bfseries extrêmement} recommandé que vous mettiez les compteurs
« tabstop » et « shiftwidth » à 4.
Le compteur « tabstop » est le nombre d'espaces que TAB ajoutera lorsque vous
éditerez sous vim. Le compteur « shiftwidth » est le nombre d'espaces qui
décaleront les lignes en tapant les commandes vi "{$>$}{$>$}" ou "{$<$}{$<$}". Référez vous
au tutorial de Vim \ref{Tutoriel Vim} {()} pour plus de détails.
Pour mettre en place tabstop et shiftwidth :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
set tabstop=4
set shiftwidth=4
set nowrapscan
set ignorecase
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Pour voir la liste des fontes disponibles sous Linux/Unix voyez la commande
{\bfseries xlsfonts}. Tapez -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        bash$ xlsfonts | less
        bash$ xlsfonts | grep -i bold | grep x
        bash$ man xlsfonts
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}







\subsection{Paramètres du Xdefaults}

Vous pouvez configurer quelques-unes des propriétés de Vim dans le fichier
Xdefaults.

{\bfseries  ATTENTION : }{\itshape Ne mettez pas {\bfseries Vim*geometry}, il coincerait
les menu gvim, utilisez plutôt {\bfseries Vim.geometry} à la place.\/}

Éditez votre \$HOME/.Xdefaults et ajoutez les lignes suivantes :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
! GVim super couleurs.
Vim*useSchemes:         all
Vim*sgiMode:            true
Vim*useEnhancedFSB:     true
Vim.foreground:         Black
!Vim.background:        lightyellow2
Vim*background:         white
! N'utilisez PAS Vim*geometry, il coincerait les menu gvim,
! utilisez Vim.geometry. Un astérisque entre Vim et geometry n'est pas autorisé.
! Vim.geometry: widthxheight
Vim.geometry:           88x40
!Vim*font:              -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-15-*5
Vim*menuBackground: yellow
Vim*menuForeground: black
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Afin que ces changements soient pris en compte, tapez :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        xrdb -merge $HOME/.Xdefaults
        man xrdb
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Vous pouvez aussi éditer votre fichier ~/.gvimrc pour changer les couleurs de
fond :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        gvim $HOME/.gvimrc
Les meilleures couleurs de fond sont jaune clair ou blanc.
        highlight Normal guibg=lightyellow
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Fichier vimrc d'exemple}

Vous pouvez changer des paramètres comme la couleur, les fontes grasses ou
normales dans le fichier gvimrc. Il est {\bfseries extrêmement} recommandé de
configurer la couleur de fond au jaune clair ou blanc. Les ergonomistes disent
que la meilleure couleur de fond est le jaune clair ou le blanc. Vous pouvez
changer la variable «~guibg~» comme suit :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        highlight Normal guibg=lightyellow
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Le fichier d'exemple de vim-5.5/runtime/vimrc\_example est celui-ci :
\begin{tscreen}
\begin{verbatim}
" Un exemple de fichier vimrc.
"
" Mainteneur :  Bram Moolenaar <Bram@vim.org>
" Dernières modifications : 9 Sep 1999
"
" Pour l'utiliser, copiez le dans
"     pour Unix et OS/2 :  ~/.vimrc
"            pour Amiga :  s:.vimrc
" pour MS-DOS and Win32 :  $VIM\_vimrc

set nocompatible        " Utilise les défauts Vim (bien mieux !)
set bs=2                " autorise l'effacement de tout en mode insertion
set ai                  " toujours utiliser l'autoindentation
set backup              " Conserver un fichier de sauvegarde
set viminfo='20,\"50    " Lit/écrit un fichier .viminfo, ne sauve pas plus
                        " de 50 lignes de registres
set history=50          " Conserve 50 lignes d'historique des commandes
set ruler               " Montre toujours la position du curseur

" Pour l'interface Win32: retirez l'option 't' de 'guioptions': pas d'entrée menu tearoff
" let &guioptions = substitute(&guioptions, "t", "", "g")

" N'utilise pas le mode Ex, utilise Q pour le formatage
map Q gq

" p en mode Visuel remplace le texte sélectionné par le registre "".
vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>

" Active la coloration syntaxique lorsque le terminal dispose de couleurs
" Active aussi la coloration de la dernière chaîne recherchée.
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

" Ne lance la partie suivante que si le support des autocommandes a été inclus
" lors de la compilation
if has("autocmd")

 " Dans les fichiers textes, toujours limiter la longueur du texte à 78
 " caractères
 autocmd BufRead *.txt set tw=78

 augroup cprog
  " Supprime toutes les autocommandes cprog
  au!

  " Lors du début d'édition d'un fichier :
  "   Pour les fichiers C et C++ active le formatage des
  "   commentaires et l'indentation C
  "   Pour les autres fichiers, les désactive.
  "   Ne pas changer l'ordre, il est important que la ligne
  "   avec * arrive avant.
  autocmd FileType *      set formatoptions=tcql nocindent comments&
  autocmd FileType c,cpp  set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
 augroup END

 augroup gzip
  " Supprime toutes les autocommandes gzip
  au!

  " Active l'édition des fichiers gzippés
  " Active le mode binaire avant de lire le fichier
  autocmd BufReadPre,FileReadPre        *.gz,*.bz2 set bin
  autocmd BufReadPost,FileReadPost      *.gz call GZIP_read("gunzip")
  autocmd BufReadPost,FileReadPost      *.bz2 call GZIP_read("bunzip2")
  autocmd BufWritePost,FileWritePost    *.gz call GZIP_write("gzip")
  autocmd BufWritePost,FileWritePost    *.bz2 call GZIP_write("bzip2")
  autocmd FileAppendPre                 *.gz call GZIP_appre("gunzip")
  autocmd FileAppendPre                 *.bz2 call GZIP_appre("bunzip2")
  autocmd FileAppendPost                *.gz call GZIP_write("gzip")
  autocmd FileAppendPost                *.bz2 call GZIP_write("bzip2")

  " Après la lecture du fichier compressé : décompresse le texte dans le
  " buffer avec "cmd"
  fun! GZIP_read(cmd)
    let ch_save = &ch
    set ch=2
    execute "'[,']!" . a:cmd
    set nobin
    let &ch = ch_save
    execute ":doautocmd BufReadPost " . expand("%:r")
  endfun

  " Après l'écriture du fichier compressé : compresse le fichier écrit avec "cmd"
  fun! GZIP_write(cmd)
    if rename(expand("<afile>"), expand("<afile>:r")) == 0
      execute "!" . a:cmd . " <afile>:r"
    endif
  endfun

  " Avant l'ajout au fichier compressé : décompresser le fichier avec "cmd"
  fun! GZIP_appre(cmd)
    execute "!" . a:cmd . " <afile>"
    call rename(expand("<afile>:r"), expand("<afile>"))
  endfun

 augroup END

 " Ce qui suit est désactivé, car il change la liste de sauts. On ne peut pas utiliser
 " CTRL-O pour revenir en arrière dans les fichiers précédents plus d'une fois.
 if 0
  " Lors de l'édition d'un fichier, saute toujours à la dernière position du curseur.
  " Ceci doit se trouver après les commandes de décompression.
   autocmd BufReadPost * if line("'\"") && line("'\"") <= line("$") | exe "normal `\"" | endif
 endif

endif " has("autocmd")
\end{verbatim}
\end{tscreen}





\subsection{Fichier gvimrc d'exemple}

L'exemple de gvimrc de vim-5.5/runtime/gvimrc\_example ressemble à
celui-ci :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
" Un exemple de fichier gvimrc.
" Ces commandes sont exécutées lors du lancement de l'interface graphique.
"
" Mainteneur :  Bram Moolenaar <Bram@vim.org>
" Dernières modifications : 2 Fév 1999
"
" Pour l'utiliser, copiez le dans
"      pour Unix et OS/2 :  ~/.gvimrc
"             pour Amiga :  s:.gvimrc
"  pour MS-DOS and Win32 :  $VIM\_gvimrc

" Passe les commandes externes par un tuyau au lieu d'un pseudo-tty
"set noguipty

" Active la fonte X11 à utiliser
" set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1

" Rend la ligne de commande de 2 lignes plus grande
set ch=2

" Permet le shift-insert fonctionnel comme dans les Xterm
map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>

" Ne fait ceci que pour Vim de version 5.0 et ultérieures.
if version >= 500

  " J'aime avoir des chaînes éclairées dans les commentaires C
  let c_comment_strings=1

  " Active la coloration syntaxique.
  syntax on

  " Active la coloration de la chaîne recherchée.
  set hlsearch

  " Pour la version Win32, on a "K" qui cherche le keyword dans un fichier d'aide
  "if has("win32")
  "  let winhelpfile='windows.hlp'
  "  map K :execute "!start winhlp32 -k <cword> " . winhelpfile <CR>
  "endif

  " Cache le pointeur de souris lorsque l'on tape
  set mousehide

  " Utilise des couleurs sympathiques
  " Le fond pour le texte normal est en gris clair
  " Le texte sous la dernière ligne est en gris sombre
  " Le curseur est gris
  " Les constantes ne sont pas soulignées mais ont un fond légèrement plus clair
  highlight Normal guibg=grey90
  highlight Cursor guibg=Green guifg=NONE
  highlight NonText guibg=grey80
  highlight Constant gui=NONE guibg=grey95
  highlight Special gui=NONE guibg=grey95

endif
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\section{Fichier d'initialisation de la coloration syntaxique}




\subsection{Méthode automatique}

La section ci-dessous provient d'une session gvim en tapant « :help syntax » -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
bash$ gvim un_test
:help syntax
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Cliquez sur le menu Window={$>$}Close\_Others pour fermer les autres fenêtres.
Utilisez ensuite CTRL+] du menu «~Procédures de chargement de syntaxe~» qui
vous emmènera sur la bonne entrée. Utilisez CTRL+T pour revenir en arrière.

Si un type de fichier que vous désirez utiliser n'est pas encore détecté, il y
a deux moyens pour l'ajouter. Il vaut mieux ne pas modifier le fichier
{\itshape \$VIMRUNTIME/filetype.vim\/}. Il sera réécrit lors de l'installation
d'une nouvelle version de ViM.
Crééz un fichier dans \$HOME/vim/myfiletypes.vim et ajoutez lui ces lignes -
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
" Nom du fichier : $HOME/vim/mestypesdefichiers.vim
" mestypesdefichiers
augroup filetype
        au! BufRead,BufNewFile *.mine   set filetype=mine
        au! BufRead,BufNewFile *.xyz    set filetype=drawing
        au! BufRead,BufNewFile *.prc    set filetype=plsql
augroup END
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Ajoutez ensuite une ligne à vos fichiers \$HOME/.vimrc et \$HOME/.gvimrc pour
initialiser la variable «~mestypesdefichiers~» au nom de ce fichier.
({\bfseries ATTENTION : } Vous DEVEZ mettre ceci dans les deux fichiers vimrc et
gvimrc pour que ceci fonctionne. Exemple :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
<code>
        let myfiletypefile = "~/vim/myfiletypes.vim"
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


{\bfseries NOTE : } Assurez vous que vous initialisez bien «~mestypesdefichiers~»
avant de passer à la détection du type de fichier. Ceci doit intervenir avant
toute commande « :filetype on » ou « :syntax on ».

Votre fichier sera alors parcouru après l'intallation des autocommandes de
type de fichier par défaut. Ceci vous permet de passer outre tous les
paramètres par défaut, en utilisant « :au! » pour supprimer les autocommandes de
type de fichier existant pour le même schéma. Seule l'autocommande pour
parcourir le fichier scripts.vim est donné plus tard. Ceci vous permettra de
vous assurer que les autocommandes dans « mestypesdefichiers » sont utilisées
avant de vérifier le contenu du fichier.




\subsection{Méthode manuelle}

Au lieu d'utiliser un menu « Syntax » vous pouvez lire manuellement le fichier
de syntaxe. Éditez le fichier avec gvim et donnez la commande « so » à : (en mode
d'échappement). Par exemple :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        gvim foo.pc
        :so $VIM/syntax/esqlc.vim
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Les fichiers de syntaxe sont dans /usr/share/vim/syntax/*.vim. Vim supporte
plus de 120 fichiers de syntaxe différents pour divers langages comme C++,
PERL, VHDL, JavaScript, etc., et énormément d'autres !

Chaque fichier de syntaxe supporte une ou plusieurs extensions de fichiers par
défaut, par exemple, le fichier de syntaxe JavaScript supporte l'extension
*.js. Si vous utilisez une extension qui crée un conflit avec un autre fichier
de syntaxe par défaut (comme ajouter du JavaScript à un fichier *.html) vous
pourrez alors charger le fichier de syntaxe additionnel avec la commande :so
\$VIM/syntax/javascript.vim. Pour éviter d'avoir à le taper, vous pouvez créer
un lien symbolique par :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        ln -s $VIM/syntax/javascript.vim js
        gvim foo.html  (... this file contains javascript functions and HTML)
        :so js
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}







\section{Usage de ViM}

Vous pouvez utiliser ViM sous deux modes, l'un avec interface graphique et
l'autre sans. Pour utiliser l'interface graphique utilisez la commande :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        gvim foo.cpp
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pour utiliser le mode non-graphique utilisez :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        vim foo.cpp
ou le mode ancien
        vi foo.cpp
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}


Il est très recommandé que vous utilisiez toujours gvim à la place de vim, car
le mode GUI avec les couleurs augmentera réellement votre productivité.

Le mode GUI gvim permet ce qui suit :
\begin{itemize}
\item  vous pouvez marquer le texte en utilisant la souris pour faire des
copier/couper/coller ;
\item  vous pouvez utiliser la barre de menu qui a les boutons File, Edit,
Window, Tools, Syntax et Help ;
\item  également dans un futur proche dans gvim - une seconde barre de menu
affichera la liste des fichiers en cours d'édition, et vous pourrez changer
entre les fichiers en cliquant sur leur nom, à moins que vous n'utilisiez les
commandes vi - :e\#, :e\#1, :e\#2, :e\#3, :e\#4, etc. pour sélectionner les
fichiers.
\end{itemize}





\section{Compagnons Vi}

En général ViM est utilisé en conjonction avec d'autres outils puissants comme
{\bfseries ctags} et {\bfseries gdb}. {\bfseries ctags} est très rapide pour la
navigation au milieu de millions de lignes de code « C/C++ » et {\bfseries gdb} est
pour le déboguage de code « C/C++ ».
Une brève introduction à ces deux commandes indispensables sera donnée dans ce
chapitre.

{\bfseries ctags} est la commande la plus puissante pour coder en C, C++, Java,
Perl, scripts shell Korn/Bourne ou Fortran. Les développeurs utilisent
intensivement {\bfseries ctags} pour naviguer au travers de milliers de
fonctions à l'intérieur de programmes C/C++. Voyez `man ctags' sous Unix.
Il est {\bfseries très important} que vous appreniez comment utiliser ctags pour
développer des programmes en C, C++, Java, etc. La navigation est la tâche
simple la plus importante lors de développement en C ou C++. L'utilisation de
ctags peut vous aider à rapidement lire le code en sautant de la ligne d'appel
à la fonction appellée, en s'enfonçant dans les appels de fonctions imbriquées,
et en remontant de la fonction la plus imbriquée jusqu'à la fonction
principale.
Vous pouvez aller et revenir de fonction en fonction très rapidement.

Sans NAVIGATION vous serez complètement perdu ! {\bfseries ctags} est comme le
COMPAS magnétique nécessaire aux programmeurs.

Utilisation de {\bfseries ctags} :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        ctags *.cpp
        gvim -t foo_function
        gvim -t main
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ceci éditera le fichier programme C++ qui contient la fonction foo\_function()
et placera directement le curseur sur la première ligne de la fonction
foo\_function(). La deuxième commande vous placera sur la ligne contenant la
définition de la fonction main().

À l'intérieur de l'éditeur ViM, vous pouvez sauter à une fonction en tapant :
(double point) tag nom\_de\_la\_fonction comme ci dessous :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        :tag fonction_exemple
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ceci placera le curseur sur la première ligne de fonction\_exemple().

Si vous voulez sauter dans la fonction à partir de la ligne du fichier
contenant le nom de la fonction, placez le curseur juste avant le nom de la
fonction et tapez {\bfseries CTRL+]} (tapez la touche de contrôle et le crochet
gauche simultanément).
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
                // code d'exemple
                switch(id_number) {
                        Case 1:
                                if ( foo_function( 22, "abcef") == 3 )
                                    ^
                                    |
                                    |
                                    |
                  Placez le curseur ici (juste avant foo_function) et tapez CTRL+]
                  Ceci vous emmènera à la fonction nommée "foo_function".
                  Pour revenir à cette ligne tapez CTRL+t
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Pour revenir à la ligne d'appel tapez {\bfseries CTRL+t} (la touche de contrôle
et la lettre 't' simultanément). Continuez à appuyer sur {\bfseries CTRL+t} pour
inverser et revenir à la première ligne où vous avez commencé la navigation.
C'est-à-dire que vous pouvez conserver pressées {\bfseries CTRL+]} et ensuite taper
{\bfseries CTRL+t} pour revenir. Vous pouvez refaire ceci aussi souvent que vous
le désirez pour avoir une navigation complète au travers de toutes les
fonctions C ou C++.




\subsection{Ctags pour ESQL}

Puisque ctags ne supporte pas directement le langage  Embedded SQL/C (ESQL),
le script shell suivant peut être utilisé pour créer les marques pour esql.
ESQL/C est un ensemble de commandes SQL de base de donnée à l'intérieur de
programmes « C ».
Le ESQL/C d'Oracle est appellé Pro*C et Sybase, Informix ont ESQL/C et
PostgreSQL a produit « ecpg ».



Sauvez ce fichier sous « sqltags.sh » et tapez chmod a+rx tags\_gen.sh.
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#!/bin/sh

# Programme pour créer les ctags pour les fichiers ESQL, C++ et C
ESQL_EXTN=pc
tag_file1=tags_file.1
tag_file2=tags_file.2

which_tag=ctags

rm -f $tag_file1 $tag_file2 tags

aa=`ls *.$ESQL_EXTN`
#echo $aa
for ii in $aa
do
        #echo $ii
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj

        if [ ! -f $jj.cpp ]; then
                echo " "
                echo " "
                echo "*******************************************************"
                echo "Les fichiers ESQL *.cpp files n'existent pas..."
                echo "Vous devez générer les fichiers *.cpp à partir des *.pc"
                echo "en utilisant le pré-compilateur Oracle Pro*C ou Sybase"
                echo "ou le pré-compilateur Informix esql/c."
                echo "Puis relancez cette commande"
                echo "*******************************************************"
                echo " "
                exit
        fi

        rm -f tags
        $which_tag $jj.cpp
        kk=s/$jj\.cpp/$jj\.pc/g

        #echo $kk > sed.tmp
        #sed -f sed.tmp tags >> $tag_file1

        #sed -e's/sample\.cpp/sample\.pc/g' tags >> $tag_file1
        sed -e $kk tags >> $tag_file1
done

# S'occupe des fichiers C++/C - exclut les fichiers ESQL *.cpp
rm -f tags $tag_file2
bb=`ls *.cpp *.c`
aa=`ls *.$ESQL_EXTN`
for mm in $bb
do
        ee=`echo $mm | cut -d'.' -f1`
        file_type="NOT_ESQL"
        # Exclut les fichiers ESQL *.cpp et *.c
        for nn in $aa
        do
                dd=`echo $nn | cut -d'.' -f1`
                if [ "$dd" = "$ee" ]; then
                        file_type="ESQL"
                        break
                fi
        done

        if [ "$file_type" = "ESQL" ]; then
                continue
        fi

        rm -f tags
        $which_tag $mm
        cat tags >> $tag_file2
done

mv -f $tag_file2 tags
cat  $tag_file1 >> tags
rm -f $tag_file1

# Doit sortir le fichier des marqueurs pour fonctionner correctement...
sort tags > $tag_file1
mv $tag_file1 tags
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Ctags pour les programmes JavaScript, les scripts shell Korn, Bourne}

Le script shell donné ci-dessous peut être utilisé pour générer les marques
pour une très large variété de programmes écrits en JavaScript, les scripts
PHP/FI, Korn, C, Bourne et beaucoup d'autres. C'est un module très générique.

Sauvez ce fichier sous tags\_gen.sh et tapez chmod a+rx tags\_gen.sh.
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
#!/bin/sh

tmp_tag=tags_file
tmp_tag2=tags_file2

echo " "
echo " "
echo " "
echo " "
echo " "
echo "Génère les marqueurs pour..."
while :
do
        echo "Entrer l'extension du fichier pour lequel vous voulez générer des marqueurs."
        echo -n "Les extensions de fichiers peuvent être sh, js, ksh, etc... : "
        read ans

        if [ "$ans" == "" ]; then
                echo " "
                echo "Mauvaise entrée. Essayez encore !"
        else
                break
        fi
done

rm -f $tmp_tag

aa=`ls *.$ans`

for ii in $aa
do
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj
        cp $ii $jj.c
        ctags $jj.c
        echo "s/$jj.c/$ii/g" > $tmp_tag2
        sed -f $tmp_tag2 tags >> $tmp_tag
        \rm -f tags $jj.c
done

sort $tmp_tag > tags

rm -f $tmp_tag $tmp_tag2
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Déboguer avec gdb}

Vous utiliserez gdb extensivement avec Vi. Le déboguage est l'un des plus
importants aspects de la programmation en tant que coût majeur du
développement et des tests des projets.

Pour déboguer des programmes C/C++ vous utiliserez l'outil « gdb ». Voyez
{\bfseries 'man gdb'}. Vous devrez compiler vos programmes avec l'option -g3
comme
\begin{tscreen}
\begin{verbatim}
        gcc -g3 foo.c foo_another.c sample.c
\end{verbatim}
\end{tscreen}


Pour configurer des alias utiles :
\begin{tscreen}
\begin{verbatim}
  Configurez l'alias dans votre ~/.bash_profile
        alias gdb='gdb -directory=/home/src -directory=/usr/monnom/src '
  Donnera -
        gdb foo.cpp
        gdb> dir /hom2/another_src
        Ceci ajoutera un chemin à la recherche de fichier
        gdb> break 'some_class::func<TAB><TAB>
  Ce qui complètera le nom de la fonction en vous évitant le temps de
frappe... et sortira comme -
        gdb> break 'some_class::function_foo_some_where(int aa, float bb)'
\end{verbatim}
\end{tscreen}


Taper la touche TAB deux fois permet le complément de la ligne de commande,
sauvant ainsi beaucoup de temps de frappe. C'est l'une des techniques les plus
importantes pour l'utilisation de gdb.

Pour obtenir de l'aide en ligne -
\begin{tscreen}
\begin{verbatim}
        gdb> help
  Donne l'aide en ligne
        gdb> help breakpoints
  Donne plus de détails sur les points d'ancrage.
\end{verbatim}
\end{tscreen}

Pour placer les points d'ancrage et effectuer du déboguage
\begin{tscreen}
\begin{verbatim}
        unixprompt> gdb exe_filename
        gdb> b main
  Ceci mettra un point d'ancrage dans la fonction main()
        gdb> b 123
  Ceci mettra un point d'ancrage à la ligne 123 du fichier courant
        gdb> help breakpoints
    Donne plus de détails sur les points d'ancrage.
\end{verbatim}
\end{tscreen}


Pour analyser des core dumps :
\begin{tscreen}
\begin{verbatim}
        unixprompt> gdb exe_filename  core
        gdb> bt
Donne une trace de retour des fonctions et les numéros de lignes où le
programme a échoué
        gdb> help backtrace
  Donne plus de détails sur la trace de retour.
\end{verbatim}
\end{tscreen}


Vous pouvez aussi utiliser une version GUI de gdb appellée xxgdb.

Outils de perte de mémoire -
\begin{itemize}
\item  Freeware Electric Fence sous linux cd
\item  Commercial tools Purify 
{\em } {\tt \aahurl}
\item  Insure++ 
{\em } {\tt \aaiurl}
\end{itemize}





\section{Aide de ViM en ligne}

Voyez les pages de manuel en ligne. Au prompt unix, tapez
{\bfseries 'man vim'} et {\bfseries 'man gvim'}.

Ou lors d'une session gvim tapez :help pour obtenir la page d'aide. Voyez
aussi le \ref{Tutoriel Vim} {()}




\section{Pages web de ViM et liens ViM}

La page principale de ViM se trouve sur 
{\em } {\tt \aajurl}
, et son
site miroir aux US est sur 
{\em } {\tt \aakurl}
.

La FAQ ViM est sur 
{\em } {\tt \aalurl}

et sur 
{\em } {\tt \aamurl}
.

La page ViM d'Eli se trouve sur 
{\em } {\tt \aanurl}
.

La page des amoureux de Vi sur 
{\em } {\tt \aaourl}
.

Le guide de référence sur ViM sur 
{\em } {\tt \aapurl}
.

Les listes de diffusion ViM sont sur 
{\em } {\tt \aaqurl}
 et 
{\em } {\tt \aarurl}
.

Les archives des listes sont conservées sur :
\begin{itemize}
\item  
{\em } {\tt \aasurl}
\item  
{\em } {\tt \aaturl}
\item  
{\em } {\tt \aauurl}
\end{itemize}


Les macros ViM sont sur 
{\em } {\tt \aavurl}
.




\section{Tutoriel ViM \label{Tutoriel Vim}}


\subsection{Tutoriels ViM sous la main \label{vimhandson}}

Sur les systèmes Linux, on trouve souvent le tutoriel dans
/usr/doc/vim-common-5.*/tutor, sur les autres systèmes Unix cherchez le
répertoire où ViM est installé et cherchez le répertoire doc.
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
        bash$ cd /usr/doc/vim-common*/tutor
        bash$ less README.txt
        bash$ cp tutor $HOME
        bash$ cd $HOME
        bash$ less tutor
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Tutoriels Vi sur Internet\label{vimurls}}

\begin{itemize}
\item  Purdue University 
{\em } {\tt \aawurl}
\item  Quick Vi tutorial 
{\em } {\tt \aaxurl}
\item  Advanced Vi tutorial 
{\em } {\tt \aayurl}
\item  Tutorials 
{\em } {\tt \aazurl}
\item  Tutorials 
{\em } {\tt \abaurl}
\item  Unix world online vi tutorial 
{\em } {\tt \abburl}
\item  Univ of Hawaii tutorial 
{\em } {\tt \abcurl}
\item  InfoBound  
{\em } {\tt \abdurl}
\item  Cornell Univ 
{\em } {\tt \abeurl}
\item  Vi Lovers home page 
{\em } {\tt \abfurl}
\item  Après Sept 2000, sera sur 
{\em } {\tt \abgurl}
\item  Beginner's Guide to vi 
{\em } {\tt \abhurl}
\item  vi Help file 
{\em } {\tt \abiurl}
\item  ViM FAQ 
{\em } {\tt \abjurl}
\end{itemize}


Il y a de nombreux tutoriels Vi sur Internet. Sur Yahoo (Lycos, excite ou
Hotbot), entrer « Vi Tutorial » dans le champ de recherche vous renverra de
nombreux pointeurs.




\section{Tutoriel Vi \label{vimtut}}

Dans ce tutoriel, nous décrirons quelques commandes et concepts {\bfseries vi}
avancés, vous pourrez ainsi apprécier la puissance de {\bfseries vi} et décider
de construire vos connaissances avec les commandes {\bfseries vi}. Quasiment
toutes les références listent les commandes disponibles, mais beaucoup ne
montrent pas comment ces commandes interagissent ; ce point précis est le thème
principal de ce tutoriel.




\subsection{Commandes du mouvement du curseur}

Les commandes du mouvement du curseur de {\bfseries vi} vous permettent de
positionner le curseur dans le fichier et/ou à l'écran de manière efficace,
avec un nombre minimal de frappe de touches. Il y a de nombreuses commandes
contrôlant les mouvements du curseur - n'essayez pas de toute les mémoriser en
une fois ! Plus tard, nous verrons que la majeure partie de la puissance de
{\bfseries vi} vient du mélange entre les commandes de mouvement du curseur et
les autres commandes pour effacer, changer, copier, et filtrer le texte.

Veuillez éditer un gros fichier texte (disons, {\bfseries wknight}) afin
d'expérimenter chaque commande décrite. Gardez en tête que ces commandes ne
marchent qu'en Mode Commande, et pas en Mode Insertion ; si vous voyez vos
« commandes » dans votre texte, appuyez sur ESC pour retourner en Mode Commande.

\begin{itemize}
\item  {\bfseries touches fléchées} : Ainsi que nous l'avons vu, les touches
curseur permettent de se déplacer avec un simple caractère vers la gauche, le
bas, le haut et la droite. Les mouvements au-delà du haut du fichier, en
dessous du bas, à droite de la fin de la ligne, ou à gauche du début ne sont
pas autorisés (pas de coupure de ligne).



\item  {\bfseries hjkl} : Lorsque {\bfseries vi} a été écrit (vers 1978), de
nombreux terminaux sur systèmes UNIX n'avaient pas de touches fléchées !
{\bfseries h, j, k,} et {\bfseries l} ont été choisies comme commandes pour se
déplacer vers la gauche, le bas, le haut, et la droite, respectivement.
Essayez les ! La plupart des intégristes de {\bfseries vi} les préfèrent aux
touches fléchées car :
\begin{itemize}
\item {\bfseries (a)} elles sont à la même place sur tous les claviers, et
\item {\bfseries (b)} elles se placent agréablement sous les doigts, au contraire
de la plupart des touches fléchées, qui sont arrangées en boîte ou en « T » ou
sous une autre forme non linéaire.
\end{itemize}


Pourquoi h, j, k, et l ? Eh bien, dans le code des caractères ascii, CTRL-H
est l'effacement (déplacement vers la gauche), CTRL-J le retour chariot
(déplacement vers le bas), et bien entendu, k et l sont proches de h et j, et
comme vous le voyez, ces touches forment une combinaison mnémonique.



\item  {\bfseries 0} : (« zéro », et pas « oh ») Déplacement au début de la ligne
courante. (Pour essayer ceci et les quelques commandes suivantes, utilisez les
touches du curseur ou {\bfseries h j k l} pour vous déplacer vers une ligne
indentée contenant quelques caractères « e ». Si vous ne pouvez trouver de ligne
indentée dans votre fichier, créez en une en insérant quelques espaces au
début de la ligne.)



\item  {\bfseries  \^{} } : Déplacement sur le premier caractère non-blanc de la
ligne courante (pour une ligne indentée, 0 et \^{} ont des significations
différentes).



\item  {\bfseries  \$ } : Déplacement sur le dernier caractère de la ligne
courante.



\item  {\bfseries  tC } : Déplacement jusqu'au (mais pas sur) le prochain
caractère C de la ligne courante (tapez 0, puis tapez te. Ceci vous déplacera
vers le premier e de la ligne courante).



\item  {\bfseries  fC } : Trouve (déplacement sur) le prochain caractère C de la
ligne courante (tapez fe, et le curseur trouvera - c'est-à-dire se mettra sur
- le prochain e de la ligne courante).



\item  {\bfseries  TC } : Déplacement jusqu'au (mais pas sur) le précédent
caractère C de la ligne courante (tapez \$, puis Te).



\item  {\bfseries  FC } : Trouve (déplacement sur) le précédent caractère C de la
ligne courante (tapez Fe).



\item  {\bfseries  n$|$ } : Déplacement sur la colonne n de la ligne courante
(tapez 20 $|$ ; les chiffres 2 et 0 ne seront pas affichés lorsque vous les
taperez, mais lorsque vous presserez $|$ le curseur se déplacera en colonne 20).

Essayez quelquez trucs avec t f T F $|$ . Lorsque vous faîtes quelque chose
d'illégal, {\bfseries vi} émettra un bip.



\item  {\bfseries  w } : Déplacement au début du prochain « petit » mot (un « petit »
mot consiste en une suite ininterrompue de caractères alphanumétiques ou de
caractères de ponctuation, mais pas un mélange de caractères de ponctuation et
alphanumériques). Essayez de taper w une douzaine de fois -- notez ce qui
arrive aux ponctuations.



\item  {\bfseries  W } : Déplacement au début du prochain « grand » mot (mélange
alphanumérique et ponctuation). Essayez de taper W une douzaine de fois.



\item  {\bfseries  b } : Retour au début d'un « petit » mot.



\item  {\bfseries  B } : Retour au début d'un « grand » mot.



\item  {\bfseries  e } : Déplacement à la fin d'un « petit » mot.



\item  {\bfseries  E } : Déplacement à la fin d'un « grand » mot.



\item  {\bfseries  + Return } : Déplacement sur le premier caractère non-blanc
sur la même ligne (+ et la touche Entrée ont le même effet).



\item  {\bfseries  - } : Déplacement sur le premier caractère non-blanc de la
ligne précédente.



\item  {\bfseries  ) } : Déplacement sur la fin d'une phrase (une phrase se
termine soit par une ligne blanche, ou un point ou une marque d'exclamation
suivis par deux caractères d'espace ou la fin de la ligne. Un point ou une
marque d'exclamation suivis par un seul caractère d'espace ne termine pas une
phrase ; ceci est un comportement correct, en accord avec les règles
traditionnelles de la manière dont les phrases doivent apparaître dans les
documents imprimés, mais apparaît souvent comme faux pour ceux qui n'ont
jamais utilisé une classe typographique correcte.)

NdT : Ceci n'est valable qu'en typographie anglaise.  En typographie
française, une phrase se termine par un point (ou une marque d'exclamation)
suivit par une espace.



\item  {\bfseries  ( } : Déplacement au début d'une phrase.



\item  {\bfseries  $\}$ } : Déplacement à la fin d'un paragraphe (les paragraphes
sont séparés par des lignes blanches, par définition avec {\bfseries vi}).



\item  {\bfseries  $\{$ } : Déplacement au début d'un paragraphe.



\item  {\bfseries  H } : Déplacement vers la position première (la ligne du haut)
de l'écran.



\item  {\bfseries  M } : Déplacement au milieu de la ligne à l'écran.



\item  {\bfseries  L } : Déplacement sur la dernière ligne de l'écran.



\item  {\bfseries  nG } : Déplacement sur la ligne n. Si n n'est pas donné,
déplacement sur la dernière ligne du fichier (essayez 15G pour vous déplacer
sur la ligne 15, par exemple. La commande CTRL-G affiche le nom du fichier,
quelques informations sur l'état, et le numéro de la ligne actuelle. Pour vous
déplacer au début du fichier : 1G).



\item  {\bfseries  CTRL-d } : Déplacement vers le bas d'un demi-écran (voir note).
\item  {\bfseries  CTRL-u } : Déplacement vers le haut d'un demi-écran (voir note).
\item  {\bfseries  CTRL-f } : Déplacement vers le bas d'un écran (voir note).
\item  {\bfseries  CTRL-b } : Déplacement vers le haut d'un écran (voir note).
\item  {\bfseries  Note } : Ces quatres commandes de déplacement ne peuvent être
utilisées avec les commandes d'effacement, de changement, de copie ou de
filtre.



\item  {\bfseries  /reg\_exp } : Déplacement sur la prochaine occurence de
l'expression rationnelle reg\_exp.
Lorsque vous tapez /, le curseur se déplace vers le coin en bas à gauche de
l'écran et attend que vous tapiez l'expression rationnelle.
Tapez la touche Entrée pour finir ; {\bfseries vi} cherchera alors dans la suite
du fichier la prochaine occurence de l'expression rationnelle. Par exemple,
tapez /the puis Entrée. Ceci vous déplacera sur la prochaine apparition de
the, peut-être mise en évidence au milieu d'un mot plus long (other, weather,
etc.). Si vous tapez juste / puis Entrée, {\bfseries vi} cherchera la prochaine
apparition de la dernière expression rationnelle que vous aviez cherché.



\item  {\bfseries  n } : A le même effet que de presser / et Entrée ; c-à-d
recherche la prochaine occurence de la dernière expression rationnelle que
vous aviez cherché.



\item  {\bfseries  ?reg\_exp } : Recherche en arrière, et pas en avant. Si la
reg\_exp n'est pas donnée, recherche la dernière expression rationnelle entrée.
Les 2 / et ? sont tournants, donc rechercher « plus bas » que le bas ou « plus
haut » que le haut du fichier est légal.



\item  {\bfseries  N } : Identique à~? et Entrée.
\end{itemize}





\subsection{Compteurs de répétitions}

La plupart des commandes de mouvements présentées ci-dessus peuvent être
précédées d'un compteur de répétitions ; le mouvement est simplement répété le
nombre de fois donné :

\begin{itemize}
\item  {\bfseries  3w } : Déplacement en avant de 3 mots.
\item  {\bfseries  5k } : Déplacement vers le haut de 4 caractères.
\item  {\bfseries  3fa } : Trouve le 3ème « a » successif de la ligne courante.
\item  {\bfseries  6+ } : Descend de 6 lignes.
\end{itemize}

Pour certaines commandes, les « compteurs de répétitions » ont des
significations spéciales :
\begin{itemize}
\item  {\bfseries  4H } : Déplacement vers la ligne 4 de l'écran (touche home et 3).
\item  {\bfseries  8L } : Déplacement sur la 8ème ligne à partir du bas de l'écran.
\item  {\bfseries  3\$ } : Déplacement à la fin de la 3ème ligne plus bas.
\end{itemize}

Pour plusieurs commandes (telles que \^{}) le compteur de répétition est ignoré ;
pour d'autres (par exemple, / et ?) il est illégal.




\subsection{Effacer du texte}

Nous avons vu que {\bfseries dd} efface la ligne courante. Ceci peut être utilisé
avec un compteur de répétitions : 3dd efface trois lignes, la ligne courante et
les 2 lignes suivantes.

La commande d peut être utilisée comme un « préfixe » pour la plupart des
commandes de mouvement ci-dessus pour effacer à peu près toute sorte de
parties de texte. Lorsqu'elles sont utilisées avec d, les commandes de
mouvements sont appellées des spécificateurs de cibles. On peut donner un
compteur de répétition à d (lorsque vous essayez ces expériences, rappellez
vous d'appuyer sur u après chaque commande pour annuler l'effacement).

\begin{itemize}
\item  {\bfseries  dw } : Efface le prochain « petit » mot.
\item  {\bfseries  d3w } : Efface les 3 prochains « petits » mots.
\item  {\bfseries  3dw } : Trois fois, efface le prochain « petit » mot.
\item  {\bfseries  3d3w } : Trois fois, efface les 3 prochains « petits » mots
(c'est-à-dire, efface les 9 prochains « petits » mots).
\item  {\bfseries  d+ } : Efface la ligne actuelle et la ligne suivante.
\item  {\bfseries  d/the }: Efface à partir du caractère courant jusqu'à, mais
sans inclure, la prochaine apparition de «~the~».
\item  {\bfseries  d\$ } : Efface jusqu'à la fin de la ligne.
\item  {\bfseries  d0 } : Efface jusqu'au début de la ligne.
\item  {\bfseries  d30G } : Efface la ligne courante jusqu'à et incluant la ligne 30.
\item  {\bfseries  dG } : Efface la ligne courante jusqu'à et incluant la
dernière ligne.
\item  {\bfseries  d1G } : Efface la ligne courante jusqu'à et incluant la ligne 1.
\end{itemize}

Pour effacer de simples caractères, utilisez x. x peut être utilisé en
utilisant un compteur répétitif :
\begin{itemize}
\item  {\bfseries  15x } : Efface le caractère courant et les 14 suivants.
\end{itemize}

x est simplement une abbréviation de d1 ; c'est-à-dire efface un caractère à
droite.




\subsection{Changer le texte}

La commande c est similaire à d, à part qu'elle change le mode de {\bfseries vi} en
insertion, autorisant le texte original (non désiré) à être changé en quelque
chose d'autre.

Par exemple, placez le curseur sur le début d'un mot (tapez w pour arriver au
début du prochain mot). Ensuite, tapez cw pour changer ce mot. À l'écran, le
dernier caractère de ce mot en cours de changement sera remplacé par un
symbole {\bfseries \$} indiquant la fin du changement ; tapez un nouveau mot (vous
réécrirez le mot original à l'écran) et tapez la touche ESC lorsque vous aurez
fini. Votre entrée peut être plus longue ou plus courte que le mot en cours de
changement.

Placez le curseur au début d'une ligne contenant au moins trois mots, et taper
c3w pour changer ces trois mots. Essayez c\$ pour changer la fin de la ligne
actuelle. Dans tous les cas où le changement affecte uniquement la ligne
courante, la fin du changement est indiquée avec \$.

Lorsqu'un changement affecte plus que la ligne courante, {\bfseries vi} efface le
texte original de l'écran et se place en mode insertion. Par exemple, essayez
c3+ pour changer la ligne courante et les trois suivantes ; {\bfseries vi}
supprime les quatres lignes originales de l'écran et se place en mode
d'insertion sur une nouvelle ligne blanche.
Comme toujours, tapez la touche ESC lorsque vous aurez fini d'entrer votre
nouveau texte.

Quelques autres commandes de changement :
\begin{itemize}
\item  {\bfseries  cc } : Change la ligne courante.
\item  {\bfseries  5cc } : Change cinq lignes (courante et quatre suivantes).
\item  {\bfseries  c/the } : Changer du caractère courant jusqu'à, mais sans
inclure, la prochaine occurence de « the ».
\item  {\bfseries  c\$ } : Change jusqu'à la fin de la ligne.
\item  {\bfseries  c30G } : Change de la ligne courante jusqu'à la ligne 30
incluse.
\item  {\bfseries  cG } : Changer de la ligne courante jusqu'à et incluant la
dernière ligne.
\item  {\bfseries  c1G } : Changer la ligne courante jusqu'à la ligne 1 incluse.
\end{itemize}





\subsection{Emmener (copier) du texte}

La commande y emmène une copie du texte dans un buffer ; le texte copié peut
être placé (ou collé) n'importe où dans le fichier en utilisant p ou P.

La forme la plus simple de copie est yy pour copier la ligne courante ; après
yy, essayez p pour mettre une copie de la ligne copiée après le curseur. En
suivant yy, vous pouvez faire autant de copie de la ligne emmenée que vous le
voulez en vous déplaçant dans le fichier et en tapant p.

Pour copier plusieurs lignes, essayez, par exemple, 5yy (copie la ligne
courante et les 4 lignes suivantes). p place une copie des lignes emmenées
après le curseur ; la séquence 5yyp « marche » mais ce n'est probablement pas ce
que vous voudriez faire. La commande P fonctionne comme p, mais place une
copie de la ligne au-dessus du curseur ; essayez la séquence 5yyP.

Autres commandes de copie :
\begin{itemize}
\item  {\bfseries  y3w } : Copie 3 mots.
\item  {\bfseries  y\$ } : Copie jusqu'à la fin de la ligne.
\item  {\bfseries  y1G } : Copie de la ligne courante jusqu'à la ligne 1
incluse.
\end{itemize}





\subsection{Filtrer le texte}

La commande de filtrage {\bfseries !} demande le nom d'une commande UNIX (qui
doit être un filtre), passe les lignes sélectionnées par ce filtre, en
remplaçant les lignes sélectionnées dans le buffer {\bfseries vi} avec la sortie
de la commande filtrante. La capacité de {\bfseries vi} à passer des parties
arbitraires de texte au travers de tout filtre UNIX ajoute une flexibilité
incroyable à {\bfseries vi}, sans « coût supplémentaire » de taille ou de
performance à {\bfseries vi} même.

Quelques exemples peuvent aider l'illustration. Créez une ligne dans votre
fichier contenant juste le mot «~who~» et absolument aucun autre texte. Placez
le curseur sur cette ligne, et tapez {\bfseries !!}. Cette commande est analogue
à dd, cc, ou yy, mais au lieu d'effacer, de changer ou de copier la ligne
courante, elle filtre la ligne courante. Lorsque vous pressez le second !, le
curseur descend vers le coin en bas à gauche de l'écran et un simple ! est
affiché, vous demandant d'entrer le nom d'un filtre. En tant que nom de
filtre, tapez «~sh~» et pressez la touche Entrée. {\bfseries sh} (le shell Bourne)
est un filtre ! Il lit l'entrée standard, exécute une partie de l'entrée
(c'est-à-dire qu'il exécute des commandes), et envoie sa sortie (la sortie de
ces commandes) à la sortie standard. Filtrer la ligne contenant « who » au
travers de «~sh~» remplace la ligne contenant «~who~» par la liste des
utilisateurs du système courant -- directement dans votre fichier !

Essayez de répéter ce procédé avec {\bfseries date}. C'est-à-dire, créez une
ligne ne contenant rien d'autre que le mot {\bfseries date}, puis placez le
curseur sur cette ligne, et tapez {\bfseries !!sh} et la touche Entrée. La ligne
contenant {\bfseries date} est remplacée par la sortie de la commande
{\bfseries date}.

Mettez votre curseur sur la première ligne de la sortie de « who ». Comptez le
nombre de lignes. Supposons, par exmple, que ce nombre soit six. Sélectionnez
alors ces six lignes à filtrer au travers de sort ; tapez {\bfseries 6!!sort} et
la touche Entrée. Les six lignes seront passées à sort, et la sortie de sort
remplacera les six lignes d'origine.

La commande filtre peut uniquement être utilisée sur des lignes complètes,
pas sur des caractères ou des mots.

Quelques autres commandes de filtres (ici, « CR » indique pressez Entrée) :
\begin{itemize}
\item  {\bfseries !/the CR sort CR} : Sort la ligne courante jusqu'à la ligne
suivante contenant « the » incluse.
\item {\bfseries  !1Ggrep the CR} : Remplace la ligne courante jusqu'à la ligne 1
incluse par les lignes contenant «~the~».
\item {\bfseries  !Gawk '$\{$print \$1$\}$' CR  }: De la ligne courante jusqu'à la fin
du fichier, remplace chaque ligne par son premier mot.
\end{itemize}





\subsection{Marquer des lignes et des caractères}

Vous pouvez marquer des lignes et des caractères pour être
utilisés en tant que cible pour des mouvements, effacement,
changement, copie, et filtration en utilisant la commande mc, où
c est une lettre minuscule.

Par exemple, mettez le curseur au milieu d'un mot et tapez ma.
Ceci marque le caractère sous le curseur sous la marque a.

Maintenant, déplacez le curseur en dehors du caractère marqué
vers une ligne différente (utilisez les flèches curseur, CTRL-u,
ou autre). Pour retourner à la ligne marquée, tapez 'a (c'est-à-dire
apostrophe, puis a). Ceci vous place sur le premier
caractère non-blanc de la ligne contenant la marque a.

Sortez de la ligne encore une fois. Pour retourner au caractère
marqué, tapez `a (apostrophe inverse, puis a). Ceci vous
déplacera sur le caractère marqué par a.

Le marquage est habituellement utilisé avec l'effacement, le
changement, la copie ou la filtration. Par exemple, déplacez le
curseur sur une autre ligne que celle contenant la marque a, et
pressez d'a (d, apostrophe, a). Ceci efface de la ligne courante
jusqu'à la ligne marquée a incluse.

Mettez le curseur au milieu d'un autre mot et tapez mb pour
mettre la marque b. Maintenant, déplacez le curseur hors de ce
mot (mais seulement de quelques lignes, ainsi vous pourrez voir
ce que nous allons faire plus facilement), et pressez d`b (d,
apostrophe inverse, b). Ceci efface le caractère courant jusqu'au
caractère marqué par b inclus.

Comme autre exemple, pour trier la sortie de who, marquez la
première ligne (ma), puis déplacez le curseur vers la dernière
ligne et taper !'asort puis la touche Entrée.

Si vous sautez jusqu'à une marque et que vous décidez de revenir
en arrière, de l'endroit d'où vous avez sauté, vous pouvez taper
'' (reviens à la ligne) ou `` (reviens au caractère).




\subsection{Nommer les tampons}

Lorsque vous effacez, modifiez, ou copier du texte, le texte original est
sauvé (jusqu'au prochain effacement, changement ou copie) dans un tampon non
nommé à partir duquel il peut être mis en utilisant p ou P. En utilisant le
tampon non nommé, seul le plus récent changement du texte peut être récupéré.

Si vous voulez effacer, changer ou copier plusieurs parties de texte et se
souvenir de toutes (jusqu'à un maximum de 26), vous pouvez donner un nom au
tampon avec la commande utilisée. Un nom de tampon est de la forme "c (double
apostrophe, c minuscule).

Par exemple, tapez "ayy pour copier la ligne courante dans le tampon a, puis
déplacez vous sur une autre ligne et tapez "byy pour copier cette ligne dans
le tampon b. Maintenant, déplacez vous n'importe où dans le fichier et tapez
"ap et "bp pour placer des copies du texte sauvé dans les tampons a et b.

Quelques autres commandes de tampon :
\begin{itemize}
\item  {\bfseries  "a6yy } : Copie 6 lignes (courante et 5 suivantes) dans le tampon a.
\item  {\bfseries  "bd1G } : Efface de la ligne courante jusqu'à la ligne 1
incluse, en sauvant les lignes effacées dans le tampon b.
\item  {\bfseries  "cy'c } : Copie de la ligne courante jusqu'à la ligne marquée
c dans le tampon c (les marques et les tampons sont distincts, et peuvent
avoir le même nom sans que {\bfseries vi} ne s'en préoccupe).
\end{itemize}





\subsection{Substitutions}

Pour échanger un bloc de texte par un autre dans les lignes de votre fichier,
utilisez la commande :s. Quelques exemples de substitutions :
\begin{itemize}
\item  {\bfseries  :1,\$s/the/THE/g } De la ligne 1 à la dernière ligne (ligne
\$), remplace le texte « the » par « THE » ; le fais globalement pour toute ligne où se
trouve un « the ».
\item  {\bfseries  :'a,.s/.*/ha ha/ } De la ligne marquée a jusqu'à la ligne
actuelle (ligne .), substitue tout ce qu'il y a sur la ligne par le texte « ha
ha ».
\end{itemize}





\subsection{Diverses «~commandes double point~»}

Toutes les commandes de double point débutent avec «~:~» ; lorsque
vous tapez ce symbole, le curseur saute vers le coin bas à gauche
de l'écran, et un prompt à deux points est affiché, attendant que
vous finissiez la commande.

Quelques exemples importants :
\begin{itemize}
\item {\bfseries :w } Écrit le contenu du tampon dans le fichier
sans quitter {\bfseries vi}.
\item {\bfseries :w abc } Écrit le contenu du tampon dans le fichier
abc (crée abc s'il n'existe pas, ou réécrit son contenu actuel
s'il existe) sans quitter {\bfseries vi}.
\item {\bfseries :1,10w  abc  } Écrit les lignes 1 à 10 dans le
fichier abc.
\item {\bfseries :'a,\$w abc  }Écrit de la ligne marquée a jusqu'à la
dernière ligne dans le fichier abc.
\item {\bfseries :e abc }Édite le fichier abc, au lieu du fichier
actuel. {\bfseries vi} affiche un message d'erreur si des
changements ont été faits au fichier actuel et qui n'ont pas été
sauvés avec :w.
\item {\bfseries :e \#  }Édite le fichier précédemment édité (des
commandes successives :e\# vont et viennent entre deux fichiers).
\item {\bfseries :f abc  }Change le nom du fichier pour le tampon
actuel vers abc.
\item {\bfseries :q }Quitte, à moins qu'il n'y ait des changements
que vous ayez faits.
\item {\bfseries :q! }Quitte, en omettant tous les changements que
vous pourriez avoir fait.
\item {\bfseries :r abc }Lit le fichier abc dans le tampon
{\bfseries vi} actuel, après la ligne sur laquelle se trouve le
curseur (essayez :r croc pour insérer une copie du fichier croc).
\item {\bfseries :!cmd }Exécute la commande cmd (who, sort, ls, etc.).
\end{itemize}





\subsection{Utiliser les options}

Diverses options peuvent affecter le «~confort~» de {\bfseries vi}. Vous pouvez
afficher toutes les diverses options pouvant être utilisées en tapant set all.
Vous pouvez également utiliser «~:set~» pour changer les options.

Par exemple, si vous désirez voir le numéro de ligne pour les lignes du
fichier que vous éditez, utilisez la commande :set number. Pour supprimer
l'affichage du numéro de ligne, utilisez la commande :set nonumber. La plupart
des options peuvent être abrégées ; :set nu affiche le numéro des lignes et
:set nonu le supprime.

Si vous utilisez :set nomagic, la signification spéciale des caractères
d'expression régulière (point, astérisque, crochet, etc.) est supprimée.
Utilisez :set magic pour restaurer ces significations particulières.

Quelques options ont une valeur. Par exemple, :set tabstop=4 affiche les
tabulations en quatre caractères d'espace, plutôt que les huit habituels.

Si vous trouvez que vous désirez toujours certaines options placées de
certaines manières, vous pouvez mettre ces commandes optionnelles dans un
fichier .exrc, ou vous pouvez utiliser la variable d'environnement EXINIT pour
spécifier les options désirées.

Par exemple, si votre shell par défaut est le shell Bourne, cette ligne peut
aller dans votre fichier .profile :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
    EXINIT='set nomagic nu tabstop=4'; export EXINIT
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Si votre shell par défaut est un C shell, cette ligne peut aller dans votre
fichier .login :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
    setenv EXINIT 'set nomagic nu tabstop=4'
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Cartographie des touches}

Si vous vous apercevez que vous utilisez encore et encore la même série de
commandes simples, vous pouvez les lier à une touche de commande inutilisée en
utilisant la commande :map. Si votre lien inclut des caractères de contrôle
comme la touche Entrée (ctrl-M en ascii) ou ESC (ctrl-{[} en ascii), vous pouvez
les faire précéder de ctrl-v pour supprimer leur signification classique.

Par exemple, cette commande relit ctrl-A pour déplacer le curseur de 55
lignes, puis revenir à la ligne vide la plus récente, changer ensuite  cette
ligne blanche par un saut de page (ctrl-L) et trois lignes blanches. C'est à
dire que chaque ctrl-A paginera la page suivante, sans couper de paragraphes
entre les pages.

Note : Dans cette commande, chaque caractère de contrôle est représenté par \^{}C,
où C est une lettre majuscule quelconque. Par exemple, ctrl-M est représenté
par \^{}M. De même, lorsque vous entrez cette commande vous ne verrez pas les
caractères ctrl-v : chaque ctrl-v se voit remplacé par la signification
spéciale du caractère de contrôle suivant, ainsi lorsque vous utiliserez la
séquence \^{}V\^{}M, tout ce que vous verrez à l'écran est un \^{}M. Dans cette
commande, \^{}M est la touche Entrée et \^{}{[} la touche ESC.
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
         :map ^A  55+?^$^V^Mcc^V^L^V^M^V^M^V^M^V^[
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}





\subsection{Éditer plusieurs fichiers}

Vous pouvez éditer plusieurs fichiers avec {\bfseries vi} en lui donnant
plusieurs noms de fichiers en arguments de ligne de commande :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
         vi croc fatherw  wknight
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Trois commandes sont utilisées pour se déplacer entre plusieurs fichiers :
\begin{itemize}
\item {\bfseries  :n  } Déplace dans le prochain fichier de la liste d'arguments
(vous devez sauver les changements avec :w ou {\bfseries vi} affichera un message
d'erreur).
\item {\bfseries  :N  }Déplace dans le fichier précédent de la liste d'arguments
(vous devez sauver les changements avec :w ou {\bfseries vi} affichera un
message d'erreur).
\item {\bfseries  :rew }Rembobine et repart du premier fichier de la liste
d'arguments.
\end{itemize}


Les commandes :n, :N et :rew sont quelques peu étranges, mais elles ont des
bénéfices importants : le contenu des tampons ("a, "b, "c, etc.) sont connus
entre les fichiers, et vous pouvez ainsi utiliser :n et :rew avec p et P pour
copier le texte vers l'un ou l'autre des fichiers. De même, la plus récente
chaîne de recherche des commandes / et ? sont les mêmes suivant les fichiers,
et vous pouvez ainsi faire des recherches répétées sur plusieurs fichiers
assez facilement.

Par exemple, tentez l'expérience suivante :
tout d'abord sortez de {\bfseries vi}, et exécutez ensuite {\bfseries vi} avec croc
et wknight en arguments :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
         $ vi croc wknight
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Dans croc, cherchez

{\bfseries     /the $<$ CR $>$ }

Copiez cette ligne dans le tampon a :

{\bfseries     "ayy }

Maintenant déplacez vous sur le prochain fichier (vous n'avez fait aucun
changement à croc, donc ça marchera) :

{\bfseries     :n $<$ CR $>$ }

Cherchez la ligne suivante contenant « the », sans retaper la chaîne de
recherche :

{\bfseries     n }

Mettez une copie du tampon après la ligne courante dans wknight :

{\bfseries     "ap }

Descendez de deux lignes, et copiez la ligne courante dans le tampon b :

{\bfseries     jj"byy }

Sauvez les changements de wknight

{\bfseries     :w $<$ CR $>$ }

Maintenant, retournez à croc

{\bfseries     :rew $<$ CR $>$ }

Cherchez encore, et mettez une copie du tampon b après la ligne trouvée :

{\bfseries     n"bp }

Sauvez les changements, et quittez {\bfseries vi}

{\bfseries     ZZ }




\subsection{Remarques finales}

Ce tutoriel était prévu pour vous introduire quelques unes des possibilités de
{\bfseries vi} que vous pouvez également retrouver dans le manuel {\bfseries vi} de
votre système ou qui ne sont pas mentionnées dans ce manuel (de nombreux
systèmes ont des manuels de qualité très variée).

Vous ne serez pas un expert {\bfseries vi} après la lecture de ce tutoriel, mais
vous aurez une bonne appréciation des possibilités de {\bfseries vi}. Seul le
temps et l'effort peuvent vous faire devenir un expert {\bfseries vi}. Mais
l'efficacité et l'universalité de {\bfseries vi} rend cet effort payant dans le
long terme.

Vous pouvez avoir décidé que vous détestez {\bfseries vi}. Très bien ! Mais prenez
garde, {\bfseries vi} demeure l'éditeur de texte standard sous UNIX - le seul
éditeur sur lequel vous pouvez compter pour être disponible sous tout système
UNIX que vous utiliserez - donc même si vous préférez utiliser quelque chose
d'autre dans la vie courante, vous seriez avisé de connaître le minimum à
propos de {\bfseries vi} qui est couvert dans ce tutoriel.




\section{Carte de référence ViM\label{vimref}}




\subsection{États Vi}

Vi a 3 modes :
\begin{enumerate}
\item  {\bfseries {\itshape mode commande\/}} - État normal et initial ; les autres
reviennent ici (utilisez {\bfseries ESC} pour stopper une commande partiellement
tapée).
\item  {\bfseries {\itshape mode d'entrée\/}} - Atteint par différentes commandes
{\bfseries a i A I o O c C s S R } et terminé par {\bfseries ESC} ou anomalement par
interruption.
\item  {\bfseries {\itshape mode ligne\/}} - C-à-d attendant une entrée après une
commande {\bfseries : }, {\bfseries / }, {\bfseries ?} ou un {\bfseries ! } (terminé par
{\bfseries CR}, stoppé par {\bfseries CTRL-c}). {\bfseries CTRL} est la touche de
contrôle : {\bfseries CTRL-c} signifie  « control c ».
\end{enumerate}





\subsection{Commandes Shell}

\begin{enumerate}
\item  {\bfseries TERM=} {\itshape code\/} Place le nom de code de votre terminal
dans la variable {\bfseries TERM}.
\item  {\bfseries export TERM} Transporte la valeur de {\bfseries TERM} (le code du
terminal) vers tout programme UNIX dépendant du terminal.
\item  {\bfseries tput init} Initialise le terminal pour qu'il fonctionne
proprement avec divers programmes UNIX.
\item  {\bfseries vi } {\itshape fichier\/} Accède à l'éditeur {\bfseries vi} afin de
pouvoir éditer le fichier spécifié.
\item  {\bfseries vi } {\itshape fichier1 fichier2 fichier3\/} Rentre trois fichiers
dans le tampon {\bfseries vi} à éditer. Ces fichiers sont {\itshape fichier1,
fichier2\/}, et {\itshape fichier3\/}.
\item  {\bfseries view } {\itshape fichier\/} Invoque l'éditeur vi sur le
{\itshape fichier\/} en mode lecture.
\item  {\bfseries vi -R } {\itshape fichier\/} Invoque l'éditeur vi sur le
{\itshape fichier\/} en mode lecture.
\item  {\bfseries vi -r } {\itshape fichier\/} Récupère le {\itshape fichier\/} et les
éditions récentes après le crash du système.
\end{enumerate}





\subsection{Activer les options}

\begin{enumerate}
\item  {\bfseries :set} {\itshape option\/} Active l'{\itshape option\/}.
\item  {\bfseries :set} {\itshape option=valeur\/} Assigne la {\itshape value\/} à l'{\itshape option\/}.
\item  {\bfseries :set no} {\itshape option\/} Désactive l'{\itshape option\/}.
\item  {\bfseries :set } Affiche les options activées par l'utilisateur.
\item  {\bfseries :set all} Affiche la liste de toutes les options, à la fois les options par défaut et celles activées par l'utilisateur.
\item  {\bfseries :set } {\itshape option\/}? Affiche les valeurs de l'{\itshape option\/}.
\end{enumerate}





\subsection{Notations utilisées}

Notations :
\begin{enumerate}
\item  {\bfseries CTRL-c} {\bfseries CTRL} est la touche de contrôle : {\bfseries CTRL-c} signifie « control c » ;
\item  {\bfseries CR} est le retour chariot (touche Entrée).
\end{enumerate}





\subsection{Interrompre, annuler}

\begin{itemize}
\item  {\bfseries ESC} Arrête l'insertion ou une commande incomplète ;
\item  {\bfseries CTRL-?} {\bfseries CTRL} est la touche de contrôle : {\bfseries CTRL-?} signifie « control ? »  supprime ou interrompt des interruptions ;
\item  {\bfseries CTRL-l} réaffiche/rafraîchit l'écran si ctrl-? l'a malmené.
\end{itemize}





\subsection{Manipulation de fichier}

\begin{itemize}
\item  {\bfseries ZZ} Sauve le fichier et sort de vi.
\item  {\bfseries :wq} Sauve le fichier et sort de vi.
\item  {\bfseries :w} Écrit le fichier courant.
\item  {\bfseries :w!} Force l'écriture du fichier courant, si le fichier est en lecture seule.
\item  {\bfseries :w{\itshape nom\/}} Écrit dans le fichier {\itshape nom\/}.
\item  {\bfseries :q} Sort de vi.
\item  {\bfseries :q!} Force la sortie de vi (annule les changements).
\item  {\bfseries :e name} Édite le fichier {\itshape nom\/}.
\item  {\bfseries :e!} Réédite, en annulant les changements.
\item  {\bfseries :e + name} Édite le fichier {\itshape nom\/}, en partant de la fin.
\item  {\bfseries :e + n} Édite en partant de la ligne {\itshape n\/}.
\item  {\bfseries :e \#} Édite un fichier alternatif.
\item  {\bfseries :n} Édite le fichier suivant de la {\itshape liste des
arguments\/}.
\item  {\bfseries :args} Liste les fichiers de la liste actuelle.
\item  {\bfseries :rew} Rembobine la liste des fichiers et édite le premier.
\item  {\bfseries :n args} Spécifie une nouvelle liste des arguments.
\item  {\bfseries :f } Affiche le fichier actuel et la ligne.
\item  {\bfseries CTRL-G} Synonyme de :f, affiche le fichier actuel et la ligne.
\item  {\bfseries :ta tag } Pour marquer l'entrée du fichier par {\itshape tag\/}.
\item  {\bfseries CTRL-] } :ta, le mot suivant est tag.
\end{itemize}





\subsection{Mouvement}

\begin{itemize}
\item  {\bfseries Flèches} Déplace le curseur.
\item  {\bfseries CTRL-d} Descend d'une demi-page.
\item  {\bfseries CTRL-u} Monte d'une demi page.
\item  {\bfseries CTRL-f} Descend d'une page entière.
\item  {\bfseries CTRL-b} Monte d'une page entière.
\item  {\bfseries :0} Déplacement au début du fichier.
\item  {\bfseries :n} Déplacement à la ligne numéro n.
\item  {\bfseries :\$} Déplacement à la fin du fichier.
\item  {\bfseries 0} Déplacement au début de la ligne.
\item  {\bfseries \^{}} Déplacement au premier caractère non-blanc.
\item  {\bfseries \$} Déplacement au début de la ligne.
\item  {\bfseries CR} Déplacement au début de la ligne suivante.
\item  {\bfseries -} Déplacement au début de la ligne précédente.
\item  {\bfseries \%} Trouve le crochet correspondant.
\item  {\bfseries G } Va à la ligne (défaut à la dernière ligne).
\item  {\bfseries {]}{]} } section/fonction suivante.
\item  {\bfseries {[}{[} } section/fonction précédente.
\end{itemize}





\subsection{Positionnement en ligne}

\begin{itemize}
\item  {\bfseries H } Première ligne de l'écran.
\item  {\bfseries L } Dernière ligne de l'écran.
\item  {\bfseries M } Ligne du milieu de l'écran.
\item  {\bfseries + } Ligne suivante, sur le premier non-blanc.
\item  {\bfseries - } Ligne précédente, sur le premier non-blanc.
\item  {\bfseries CR } Entrée, pareil que +.
\item  {\bfseries j } Ligne suivante, même colonne.
\item  {\bfseries k } Ligne précédente, même colonne.
\end{itemize}





\subsection{Positionnement des caractères}

\begin{itemize}
\item  {\bfseries 0 } Début de la ligne.
\item  {\bfseries \$ } Fin de la ligne.
\item  {\bfseries h } Avance.
\item  {\bfseries l } Recule.
\item  {\bfseries SPACE } Pareil que l.
\item  {\bfseries fx } Trouve x en avant.
\item  {\bfseries Fx } Trouve x en arrière.
\item  {\bfseries ; } Répète le dernier f F.
\item  {\bfseries , } Inverse de ; .
\item  {\bfseries $|$ } Vers la colonne spécifiée.
\item  {\bfseries \% } Trouve le $\{$ ou $\}$ correspondant.
\end{itemize}





\subsection{Mots, phrases, paragraphes}

\begin{itemize}
\item  {\bfseries w } Mot en avant.
\item  {\bfseries b } Mot en arrière.
\item  {\bfseries e } Fin du mot.
\item  {\bfseries ) } Phrase suivante.
\item  {\bfseries ( } Phrase précédente.
\item  {\bfseries $\}$ } Paragraphe suivant.
\item  {\bfseries $\{$ } Paragraphe précédent.
\item  {\bfseries W } Mot délimité par du blanc.
\item  {\bfseries B } Retour d'un mot blanc.
\item  {\bfseries E } Fin d'un mot blanc.
\end{itemize}





\subsection{Marquage et retour}

\begin{itemize}
\item  {\bfseries ``} (taper deux fois la touche `) Contexte précédent.
\item  {\bfseries ''} (taper deux fois la touche ') Contexte précédent au premier non-blanc de la ligne.
\item  {\bfseries mx} Marque la position avec la lettre x.
\item  {\bfseries `x} (touche ` et lettre x) Va à la marque x.
\item  {\bfseries 'x} Va à la marque x au premier non-blanc de la ligne.
\end{itemize}





\subsection{Corrections au cours de l'insertion}

\begin{itemize}
\item  {\bfseries CTRL-h} Efface le dernier caractère.
\item  {\bfseries CTRL-w} Efface le dernier mot.
\item  {\bfseries erase } Taper la touche DELETE, pareil que CTRL-h.
\item  {\bfseries kill } Votre touche kill, efface l'entrée de la ligne.
\item  {\bfseries $\backslash$ } Échappement de CTRL-h, efface et kill.
\item  {\bfseries ESC } Stoppe l'insertion, retourne en commande.
\item  {\bfseries CTRL-? } Interrompt, termine l'insertion.
\item  {\bfseries CTRL-d } Retour de tabulation sur un {\itshape autoindent\/}.
\item  {\bfseries CTRL-v } Affiche un caractère non affichable.
\end{itemize}





\subsection{Ajuster l'écran}

\begin{itemize}
\item  {\bfseries CTRL-l} Efface et redessine.
\item  {\bfseries CTRL-r} Redessine, élimine les lignes @.
\item  {\bfseries z-CR} Redessine avec la ligne courante en haut.
\item  {\bfseries z-} Redessine, avec la ligne courante au bas de la fenêtre.
\item  {\bfseries z.} Redessine, avec la ligne courante au centre de la fenêtre.
\item  {\bfseries /pat/z-} Ligne contenant {\itshape pat\/} en bas.
\item  {\bfseries tn} Utilise une fenêtre de n lignes.
\item  {\bfseries CTRL-e} Descend la fenêtre d'une ligne.
\item  {\bfseries CTRL-y} Remonte la fenêtre d'une ligne.
\end{itemize}





\subsection{Effacer}

\begin{itemize}
\item  {\bfseries x} Efface le caractère sous le curseur.
\item  {\bfseries X} Efface le caractère avant le curseur.
\item  {\bfseries D} Efface jusqu'à la fin de la ligne.
\item  {\bfseries d\^{}} Efface jusqu'au début de la ligne.
\item  {\bfseries dd} Efface la ligne.
\item  {\bfseries ndd} Efface {\itshape n\/} lignes en commençant à la ligne
actuelle.
\item  {\bfseries dnw} Efface {\itshape n\/} mots en partant du curseur.
\end{itemize}





\subsection{Insérer, changer}

\begin{itemize}
\item  {\bfseries i} Passe en mode d'insertion avant le curseur.
\item  {\bfseries I} Passe en mode d'insertion avant le premier caractère non-blanc.
\item  {\bfseries a} Passe en mode d'insertion après le curseur.
\item  {\bfseries A} Passe en mode d'insertion après la fin de la ligne.
\item  {\bfseries o} Ouvre une nouvelle ligne en dessous de la ligne courante et passe en mode d'insertion.
\item  {\bfseries O} Ouvre une nouvelle ligne au dessus de la ligne courante et passe en mode d'insertion.
\item  {\bfseries r} Remplace le caractère en dessous du curseur (ne passe PAS en mode d'insertion).
\item  {\bfseries R} Entre en mode d'insertion en remplaçant les caractères.
\item  {\bfseries C} shift-c. Change le reste de la ligne.
\item  {\bfseries D} shift-d. Efface le reste de la ligne.
\item  {\bfseries s} Substitue des caractères.
\item  {\bfseries S} Substitue des lignes.
\item  {\bfseries J} Joint les lignes.
\end{itemize}





\subsection{Copier et coller}

Le tampon de copie est rempli par {\itshape TOUTE\/} commande d'effacement, ou explicitement par {\bfseries Y} et {\bfseries yy}.
\begin{itemize}
\item  {\bfseries Y} Copie la ligne courante dans le tampon.
\item  {\bfseries {\itshape n\/}yy} Copie {\itshape n\/} lignes en partant de la ligne actuelle dans le tampon.
\item  {\bfseries p} Colle le tampon après le curseur (ou sous la ligne
actuelle).
\item  {\bfseries P} Colle le tampon avant le curseur (ou avant la ligne actuelle).
\item  {\bfseries "{\itshape x\/}p } Colle à partir du buffer x.
\item  {\bfseries "{\itshape x\/}y } Copie dans le tampon x.
\item  {\bfseries "{\itshape x\/}d } Efface dans le tampon x.
\end{itemize}





\subsection{Opérateurs (utiliser des doubles pour agir sur les lignes complètes)}

\begin{itemize}
\item  {\bfseries d } Effacer.
\item  {\bfseries c } Changer.
\item  {\bfseries {$<$} } Déplacement gauche.
\item  {\bfseries {$>$} } Déplacement droit.
\item  {\bfseries ! } Filtrer au travers de la commande.
\item  {\bfseries = } Indenter pour LISP.
\item  {\bfseries y } Copier le texte dans le tampon.
\end{itemize}





\subsection{Chercher et remplacer}

\begin{itemize}
\item  {\bfseries /{\itshape texte\/}} Cherche en avant pour {\itshape texte\/}.
\item  {\bfseries ?{\itshape texte\/}} Cherche en arrière pour {\itshape texte\/}.
\item  {\bfseries n} Répète la dernière recherche dans la même direction.
\item  {\bfseries N} Répète la dernière recherche dans la direction inverse.
\item  {\bfseries /} Répète la dernière recherche en avant.
\item  {\bfseries ?} Répète la dernière recherche en arrière.
\item  {\bfseries {[} addr {]} s/from/to/ {[} g {]} } Cherche une occurence de {\itshape from\/} et remplace par {\bfseries {\itshape to\/}} dans la ligne actuelle, ou dans le bloc.
{\bfseries {\itshape addr\/}} (deux numéros de lignes séparés par une commande ; 1,\$ est le fichier entier) remplace une occurence par ligne, ou toutes les occurences si {\bfseries {\itshape g\/}} est spécifié.
Par exemple, :3,20s/unmot/unautre/g remplacera "unmot" par "unautre" de la ligne 3 à la ligne 20. 'g' est global et signifie que toutes les occurences de "unmot" seront remplacées.
\end{itemize}





\subsection{Général}

\begin{itemize}
\item  {\bfseries :sh} Donne un shell (à quitter avec CTRL-d).
\item  {\bfseries :!{\itshape commande\/}} Lance un shell pour exécuter {\itshape commande\/}.
\item  {\bfseries :set number} Active la numérotation des lignes.
\item  {\bfseries :set nonumber} Désactive la numérotation des lignes.
\end{itemize}





\subsection{Commandes d'édition de ligne}

\begin{itemize}
\item  {\bfseries :} Prévient {\bfseries vi} que les prochaines commandes seront des commandes pour l'éditeur de ligne.
\item  {\bfseries :sh} Retourne temporairement au shell pour exécuter quelques commandes shell sans quitter {\bfseries vi}.
\item  {\bfseries CTRL-d} Sort du shell temporaire et retourne sous {\bfseries vi} afin de pouvoir éditer la fenêtre actuelle.
\item  {\bfseries :}{\itshape n\/} Va à la {\itshape n\/}ème ligne du tampon.
\item  {\bfseries :}{\itshape x,z\/}{\bfseries w} {\itshape fichier\/} Écrit les lignes {\itshape x\/} à {\itshape z\/} dans un nouveau fichier appellé {\itshape fichier\/}.
\item  {\bfseries :\$} Déplace le curseur au début de la dernière ligne du tampon.
\item  {\bfseries :.,\$d} Efface toutes les lignes de la ligne actuelle à la dernière ligne.
\item  {\bfseries :r} {\itshape fichier\/} Insère le contenu du fichier {\itshape fichier\/} sous la ligne actuelle du tampon.
\item  {\bfseries :s}{\itshape /texte/autre\_texte/\/} Remplace la première apparition de {\itshape texte\/} sur la ligne actuelle par {\itshape autre\_texte\/}.
\item  {\bfseries :s}{\itshape /texte/autre\_texte/g\/} Remplace toutes les apparitions de {\itshape texte\/} sur la ligne actuelle par {\itshape autre\_texte\/}.
\item  {\bfseries :g}{\itshape /texte/s//autre\_texte/g\/} Change toutes les apparitions de {\itshape texte\/} dans le tampon par {\itshape autre\_texte\/}.
\end{itemize}





\subsection{Autres commandes}

\begin{itemize}
\item  {\bfseries u} Annule le dernier changement.
\item  {\bfseries U} Restaure la ligne actuelle.
\item  {\bfseries \~{}} Change la casse.
\item  {\bfseries J} Joint la ligne actuelle et la ligne suivante.
\item  {\bfseries .} Répète la dernière commande de changement de texte.
\item  {\bfseries CTRL-g} Montre le nom du fichier et le nombre de lignes.
\end{itemize}





\section{URLs connexes}

Les URLs connexes à ViM sont sur :
\begin{itemize}
\item  C et C++ Beautifer 
{\em } {\tt \abkurl}
\item  Linux goodies 
{\em } {\tt \ablurl}
 ou sur 
{\em } {\tt \abmurl}
\end{itemize}







\section{Autres formats de ce document}

Ce document est publié sous 11 formats différents, nommément - DVI,
Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF(Rich Text Format), Plain-text,
pages man Unix et SGML.
\begin{itemize}
\item Vous pouvez obtenir ce document howto sous la forme d'une archive tar en html,
dvi, postscript et sgml de :

{\em } {\tt \abnurl}

\item Le format texte plein est sur :

{\em } {\tt \abourl}

\item Les traductions dans d'autres langages comme français, allemand,
espagnol, chinois, japonais sont sur

{\em } {\tt \abpurl}
.
Toute aide de votre part pour traduire ce document dans d'autres langages est
la bienvenue.
\end{itemize}

Ce document est écrit en utilisant un outil nommé « SGML tools » qui peut être
obtenu de :

{\em } {\tt \abqurl}
.
Pour compiler le source vous obtiendrez les commandes suivantes comme :
\begin{itemize}
\item sgml2html Vim-howto.sgml     (pour générer un fichier html)
\item sgml2rtf Vim-howto.sgml     (pour générer un fichier RTF)
\item sgml2latex Vim-howto.sgml    (pour générer un fichier latex)
\end{itemize}


Les documents LaTeX peuvent être convertis en fichiers PDF en produisant
simplement une sortie Postscript en utilisant {\bfseries sgml2latex} (et dvips)
et en utilisant la sortie via la commande Acrobat {\bfseries distill} (
{\em } {\tt \abrurl}
) comme suit :
\par
\addvspace{\medskipamount}
\nopagebreak\hrule
\begin{verbatim}
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &
\end{verbatim} 
\nopagebreak\hrule 
\addvspace{\medskipamount}

Ou vous pouvez utiliser la commande Ghostscript {\bfseries ps2pdf}. ps2pdf est un
clone pour la majorité des fonctionnalités du produit Adobe's Acrobat
Distiller : il convertit les fichiers PostScript en fichiers Portable Document
Format (PDF).
{\bfseries ps2pdf} est implémenté sous la forme d'un fichier script de commandes
très petit qui invoque Ghostscript, en sélectionnant un périphérique de sortie
spécial nommé {\bfseries pdfwrite}. Afin d'utiliser ps2pdf, le périphérique
pdfwrite doit être inclus dans le makefile lors de la compilation Ghostscript ;
voyez la documentation sur la compilation de Ghostscript pour les détails.

Ce document se trouve sur :
\begin{itemize}
\item  
{\em } {\tt \absurl}
\end{itemize}


Vous pouvez aussi trouver ce document sur les sites miroirs suivants :
\begin{itemize}
\item  
{\em } {\tt \abturl}
\item  
{\em } {\tt \abuurl}
\item  
{\em } {\tt \abvurl}
\item  
{\em } {\tt \abwurl}

\item D'autres sites miroirs près de vous (à l'échelle du réseau) peuvent se
trouver sur

{\em } {\tt \abxurl}
,
sélectionnez un site et allez voir le fichier /LDP/HOWTO/Vim-HOWTO.html.
\end{itemize}


Afin de voir un document au format dvi, utilisez le programme xdvi. Le
programme xdvi se trouve dans le paquetage tetex-xdvi*.rpm de la Redhat Linux
qui peut se trouver dans ControlPanel $|$ Applications $|$ Publishing $|$ TeX.

Pour lire un document dvi utilisez la commande :

\begin{tscreen}
\begin{verbatim}
        xdvi -geometry 80x90 howto.dvi
        man xdvi
\end{verbatim}
\end{tscreen}


Et redimmensionnez la fenêtre avec une souris. Voyez la page man de
xdvi. Pour naviguer utilisez les flèches, les touches page up, down,
ou également les lettres 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' pour
monter, descendre, centrer, page suivante, page précédente, etc. Pour
supprimer le menu expert appuyez sur 'x'.

Vous pouvez lire le fichier postscript avec le programme 'gv' (ghostview) ou
'ghostscript'.
Le programme ghostscript est dans le paquetage ghostscript*.rpm et le
programme gv dans gv*.rpm, qui se trouvent sous ControlPanel $|$ Applications $|$
Graphics. Le programme gv est beaucoup plus agréable à utiliser que
ghostscript.

Ghostscript et gv sont aussi disponibles sous d'autres
plateformes comme OS/2, Windows 95 et NT. Vous pouvez donc lire ce document
sur toutes ces plateformes.

\begin{itemize}
\item Prenez ghostscript pour Windows 95, OS/2, et tous les OS sur

{\em } {\tt \abyurl}
\end{itemize}


Pour lire le document postscript utilisez la commande :

\begin{tscreen}
\begin{verbatim}
        gv howto.ps
        ghostscript howto.ps
\end{verbatim}
\end{tscreen}


Vous pouvez lire le document en html en utilisant Netscape Navigator,
Microsoft Internet explorer, Redhat Baron ou tout autre des 10 navigateurs
web.

Vous pouvez lire la sortie LaTeX ou LyX en utilisant LyX ou vim.




\section{Notice de Copyright}

Le Copyright est GNU/GPL comme pour le LDP (Linux Documentation project). Le
LDP est un projet GNU/GPL.
Les restrictions additionnelles sont - vous devez conserver le nom de
l'auteur, l'adresse mail et cette notice de Copyright sur toutes les copies.
Si vous effectuez un changement ou une addition à ce document, vous devez
notifier tous les auteurs de ce document.



\end{document}
